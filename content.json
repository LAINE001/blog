{"posts":[{"title":"EventLoop","text":"javascript 事件循环机制 1234567891011121314151617// javascript 事件循环机制分为浏览器和node事件循环机制// 浏览器Event Loop是HTML中定义的规范// Node Event Loop 是由libuv 库实现。JavaScript有一个main thread 主线程和call-stack调用栈（执行栈），所有的任务都会放到调用栈中等待主线程执行。1. JS 调用栈 是一种先进后出的数据结构。当函数被调用时，会被添加到栈中的顶部。 执行完成之后就从栈顶部移出该函数，直到栈内被清空。2. 同步任务、异步任务 JavaScript单线程中的任务分为同步任务和异步任务。 同步任务会在调用栈中按照顺寻排队等待主线程执行。 异步任务则会在异步有了结果之后将注册的回调函数添加到任务队列（消息队列）中等待主线程空闲的时候， 也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。3. Event Loop 调用栈中的同步任务都型执行完毕，栈内被清空了，就代表主线程空闲了， 这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。 每次栈内被清空，都会去读取任务队列，有就读取执行，一直循环-执行操作，就形成了事件循环。","link":"/blog/2019/09/10/EventLoop/"},{"title":"Vue原理一","text":"# vue 源码目录 123456789101112131415161718192021222324├── build --------------------------------- 构建相关的文件├── dist ---------------------------------- 构建后文件的输出目录├── examples ------------------------------ 存放使用Vue开发的的例子├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)├── package.json -------------------------- 项目依赖├── test ---------------------------------- 包含所有测试文件├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码│ ├──platforms --------------------------- 包含平台相关的代码│ │ ├──web ----------------------------- 包含了不同构建的包的入口文件│ │ | ├──entry-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意│ │ | ├── entry-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器│ ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数│ │ ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码│ │ ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码│ │ ├── optimizer.js ------------------ 分析静态树，优化vdom渲染│ ├── core ------------------------------ 存放通用的，平台无关的代码│ │ ├── observer ---------------------- 反应系统，包含数据观测的核心代码│ │ ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码│ │ ├── instance ---------------------- 包含Vue构造函数设计相关的代码│ │ ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── components -------------------- 包含抽象出来的通用组件│ ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码│ ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包│ ├── shared ---------------------------- 包含整个代码库通用的代码 # Vue 构造函数 目录 /src/instance/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}// 在vue的原型prototype上挂载方法或属性 都在/src/core/instance目录下initMixin(Vue)stateMixin(Vue)eventMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue// initMixinVue.prototype._init = function (options) {}// stateMixinVue.prototype.$dataVue.prototype.$propsVue.prototype.$setVue.prototype.$delete = delVue.prototype.$watch = function () {}// eventsMxinVue.prototype.$onVue.prototype.$onceVue.prototype.$offVue.prototype.$emit// lifecycleMixinVue.prototype._updateVue.prototype.$forceUpdateVue.prototype.$destory// renderMixinVue.prototype.$nextTick Vue.prototype._render Vue.prototype._o = markOnce Vue.prototype._n = toNumber Vue.prototype._s = toString Vue.prototype._l = renderList Vue.prototype._t = renderSlotVue.prototype._q = looseEqual Vue.prototype._i = looseIndexOf Vue.prototype._m = renderStatic Vue.prototype._f = resolveFilter Vue.prototype._k = checkKeyCodes Vue.prototype._b = bindObjectProps Vue.prototype._v = createTextVNode Vue.prototype._e = createEmptyVNode Vue.prototype._u = resolveScopedSlots Vue.prototype._g = bindObjectListeners # 初始化实列 根据 Vue 的生命周期，Vue 首先会进行 init 初始化操作； 源码在 src/core/instance/init.js 中 123456789101112131415161718/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, 'created') # 引入依赖，挂载静态方法和属性 123456789101112131415161718192021222324252627// [/src/core/index.js](https://github.com/vuejs/vue/blob/dev/src/core/index.js)import Vue from './instance/index'import { initGlobalAPI } from './global-api/index'import { isServerRendering } from 'core/util/env'// import { FunctionalRenderContext } from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', { get: isServerRendering})Object.defineProperty(Vue.prototype, '$ssrContext', { get () { /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext }})// expose FunctionalRenderContext for ssr runtime helper installation// Object.defineProperty(Vue, 'FunctionalRenderContext', {// value: FunctionalRenderContext// })Vue.version = '__VERSION__'export default Vue # 进入 global-api 1234567891011121314151617181920Vue.set = setVue.delete = delVue.nextTick = nextTick// ASSET_TYPES: ['component', 'directive', 'filter']// ASSET_TYPES.forEach(type =&gt; {// Vue.options[type + 's'] = Object.create(null)// })Vue.options = { components: { KeepAlive }, directives: {}, filters: {}, _base: Vue}Vue.use Vue.mixin Vue.cid = 0 Vue.extend Vue.component = function(){} Vue.directive = function(){} Vue.filter = function(){} # Object.defineProperty 响应式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // ... Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} # VNode 概念 1234567891011121314151617181920212223242526272829export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching fnScopeId: ?string; // ...}","link":"/blog/2020/04/20/Vue%E5%8E%9F%E7%90%86%E4%B8%80/"},{"title":"vue-axios","text":"# Vue 中封装 axios 的一种方法 安装 axios 1npm install axios --save 单独写个文件配置 axios, 此处命名为 request.js 1234567891011121314151617181920212223242526272829import axios from axios//自定义配置新建一个axios实例const http = axios.create({ // baseURL: 'https://...' // baseURL: process.env.BASE_API, timeout: 5000, // 请求延迟 // headers: {'x-Request-with': '*'} //自定义请求头 // ....})// 添加请求拦截器http.interceptors.request.use(config =&gt; { // 请求前设置请求头 config.headers['Access-Control-Allow-Origin'] = '*' // config.headers['Authorization'] = getToken() // config.headers['Actcode'] = getCode() return config}, error =&gt; { console.log(error, '888') //请求错误 dsth return Promise.reject(error)})// 响应拦截器http.interceptors.response.use(response =&gt; { return response}, error =&gt; { console.log(error, '888')//返回消息后 dsth return Promise.reject(error)})export default http // 记住此处 api.js 文件中配置请求 12345678910import http from '@/http/request'export function requestDemo (showapi_appid, showapi_sign) { //方法名 requestDemo const pass = {showapi_appid, showapi_sign} return http({ url: 'http://route.showapi.com/60-27', method: 'post', data: pass })} 页面中使用 1234567import { requestDemo } from '@/../api'const params = { name: 'laine', pw: '123456'}requestDemo(params).then().catch()","link":"/blog/2019/07/20/axios%E5%B0%81%E8%A3%85/"},{"title":"洋葱模型","text":"# 一个请求通过经过中间件最后生成响应 # 基于 koa2 的 demo 12345678910111213141516171819202122232425const Koa = require('koa');const app = new Koa();const PORT = 3000;// #1app.use(async (ctx, next)=&gt;{ console.log('wareA') await next(); console.log('wareA')});// #2// app.use和eggjs里配置config.middleware = []同理app.use(async (ctx, next) =&gt; { console.log('wareB') await next(); console.log('wareB')})app.use(async (ctx, next) =&gt; { console.log('wareC')})app.listen(PORT); 访问 localhost:3000, 控制台输出 12345wareAwareBwareCwareBwareA 当程序运行到 await next () 时，会进入到下一个中间件，处理完之后才会继续处理 next 之后的程序 可以非常方便的实现后置处理逻辑","link":"/blog/2022/12/08/egg%E5%92%8Ckoa%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B/"},{"title":"hello 算法笔记","text":"最近开始看朋友推荐的 hello算法 ，平时对算法都不太懂，看了这本书的其中一点，有一些还是写的很好的，起码对于算法小白的我，很多比方都比喻的特别好。这里记录下看整本书的笔记。 # 1. 前言 # 本书主要内容： 复杂度分析：数据结构和算法的评价维度与方法。时间复杂度、空间复杂度的推算方法、常见类型、示例等。 数据结构：基本数据类型，数据结构的分类方法。数组、链表、栈、队列、散列表、树、堆、图等数据结构的定义、优缺点、常用操作、常见类型、典型应用、实现方法等。 算法：搜索、排序、分治、回溯、动态规划、贪心等算法的定义、优缺点、效率、应用场景、解题步骤、示例题目等 # 2. 初识 # 算法无处不在 查阅字典实际就是著名的『二分查找』。数据结构角度：字典为已排序的数组，算法角度：查字典过程即为二分查找 查阅字典。字典是按照拼音顺序排列的，假如需要查找首字母为 r 的字，通常是以下操作 翻开字典大概一半的页数，查看首字母是什么，假设为 m （l、m、n、o、p、q、r、s、t） 因为 r 是在 m 之后，所以可以排除前半部分，查找范围缩小为了后半部分 重复 1. 和 2.，直到找到首字母为 r 的页码 整理扑克本质上就是『插入排序』算法，在处理小型数据集是很高效 整理扑克。在打扑克时，每一局都需要整理扑克牌，使其小到大排列，实现流程： 将扑克牌划分为 有序 和 无序 两部分，并假设初始时，最左边的 1 张扑克已经有序 在无序区间里取出一张插入至有序区间中的位置；完成后最左边 2 张扑克已经有序 再从无序区间里取出一张插入至有序区间中的位置；完成后最左边 3 张扑克已经有序 循环以上操作，至所有有序 下面的货币找零方案，从数据结构和算法角度看就是「贪心算法」。（每一步都采取当前看起来最好的选择） 货币找零：假设我们在超市购买了 69 元的商品，付给了收银员 100 元，收银员需要找回，他会很自然的油以下思考 能找到的可选零钱包括 1 元、5 元、10 元、20 元 从可选项中拿出最大的 20 元。剩余 31-20=11 元 从剩余可选项中拿出 10 元。剩余 11-10=1 元 从剩余可选项中拿出 1 元，剩余 1-1=0 元 完成找零，方案为 20+10+1=31 元 # 算法是什么 # 算法定义 算法 Algorithm 是在有限时间内解决特定问题的一组指令或操作步骤。算法具有以下特性： 问题是明确的，包含清晰的输入和输出定义。 具有可行性，能够在有限步骤、时间和内存空间下完成。 各步骤都有确定的含义，相同的输入和运行条件下，输出始终相同。 # 数据结构定义 「数据结构 Data Structure」是计算机中组织和存储数据的方式。为了提高数据存储和操作性能，数据结构的设计目标包括： 空间占用尽量减少，节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便使得算法高效运行 # 数据结构和算法的关系 「数据结构」与「算法」高度相关且紧密结合，具体表现在： 数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及用于操作数据的方法。 算法是数据结构发挥的舞台。数据结构本身仅存储数据信息，通过结合算法才能解决特定问题。 特定算法通常有对应最优的数据结构。算法通常可以基于不同的数据结构进行实现，但最终执行效率可能相差很大。 如下： 数据结构与算法 LEGO 乐高 输入数据 未拼装的积木 数据结构 积木组织形式，包括形状、大小、连接方式等 算法 把积木拼成目标形态的一系列操作步骤 输出数据 积木模型 # 3. 复杂度 # 时间复杂度 运行时间可以直观且准确的反映算法的效率。怎样才算准确？1 确定运行平台、2 评论各个计算操作的时间、3 统计所有的计算操作时间，事实上，运行时间不能和运行平台绑定，其次每个操作的时间很难获取到。 所以「时间复杂度的分析」采取的统计是，算法运行时间随着数据量变大时的增长趋势 1234567891011// 在某运行平台下的各个时间// 1 + 1 + 10 + 1 + 5 nsfunction algorithm(n) { var a = 2; // 1ns a = a + 1; // 1ns a = a * 2; // 10ns for(let i = 0; i &lt; n; i++) { // 1ns console.log(0); // 5 ns }} ::: 推算方法：统计操作数量、判断渐近上界 见 hello 算法 ::: # 时间复杂度常见类型 常见的时间复杂度类型（低到高） 常数阶 O (1) 对数阶 O (log n) 线性阶 O (n) 线性对数阶 O (n log n) 平方阶 O (n²) 指数阶 O (2 的 n 次方) 阶乘阶 O (n!) # 常数介阶 常数阶的操作数量与输入数据大小 n 无关，即不会随便 n 的变化而变化 12345678/* 常数阶 */function constant(n) { let count = 0; const size = 100000; for (let i = 0; i &lt; size; i++) count++; return count;} # 线性阶 线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在 单层循环 中。 1234567/* 线性阶 */// 操作数组或链表时，n为数组或链表的长度function linear(n) { let count = 0; for (let i = 0; i &lt; n; i++) count++; return count;} # 平方阶 平方阶的操作数量相对于输入数据大小以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环都为 O (n) ，因此总体为 O (n^2) 。 123456789101112131415161718192021222324252627282930/* 平方阶 */function quadratic(n) { let count = 0; // 循环次数与数组长度成平方关系 for (let i = 0; i &lt; n; i++) { for (let j = 0; j &lt; n; j++) { count++; } } return count;}// 下面是常见的冒泡排序(平方阶)function bubbleSort(nums) { let count = 0; // 计数器 // 外循环：未排序区间为 [0, i] for (let i = nums.length - 1; i &gt; 0; i--) { // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (let j = 0; j &lt; i; j++) { if (nums[j] &gt; nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] let tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; count += 3; // 元素交换包含 3 个单元操作 } } } return count;} # 指数阶 生物学的 “细胞分裂” 是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 n 轮后有 2^n 个细胞。 指数阶增长非常迅速，在实际应用中通常是不可接受的。若一个问题使用「暴力枚举」求解的时间复杂度为 O (2^n) ，那么通常需要使用「动态规划」或「贪心算法」等方法来解决 12345678910111213141516171819202122/* 指数阶（循环实现） */function exponential(n) { let count = 0, base = 1; // cell 每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1) for (let i = 0; i &lt; n; i++) { for (let j = 0; j &lt; base; j++) { count++; } base *= 2; } // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1 return count;}// 实际算法中，指数阶常出现于递归函数/* 指数阶（递归实现） */function expRecur(n) { if (n === 1) return 1; return expRecur(n - 1) + expRecur(n - 1) + 1;} # 对数阶 与指数阶相反，对数阶反映了 “每轮缩减到一半的情况”。对数阶仅次于常数阶，时间增长缓慢，是理想的时间复杂度。 对数阶常出现于「二分查找」和「分治算法」中，体现了 一分为多 和 化繁为简 的算法思想。 设输入数据大小为 n ，由于每轮缩减到一半，因此循环次数是 log_2 n ，即 2^n 的反函数。 12345678910111213141516/* 对数阶（循环实现） */function logarithmic(n) { let count = 0; while (n &gt; 1) { n = n / 2; count++; } return count;}// 与指数阶类似，对数阶也常出现于递归函数。以下代码形成了一个高度为 \\(\\log_2 n\\) 的递归树/* 对数阶（递归实现） */function logRecur(n) { if (n &lt;= 1) return 0; return logRecur(n / 2) + 1;} # 线性对数阶 线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O (log n) 和 O (n) 主流排序算法的时间复杂度通常为 O (n log n) 。例如：快速排序、归并排序、堆排序等。 123456789/* 线性对数阶 */function linearLogRecur(n) { if (n &lt;= 1) return 1; let count = linearLogRecur(n / 2) + linearLogRecur(n / 2); for (let i = 0; i &lt; n; i++) { count++; } return count;} # 阶乘阶 对应数学上的「全排列问题」。见 hello 算法 阶乘通常使用递归实现。例如以下代码，第一层分裂出 n 个，第二层分裂出 n - 1 个，以此类推，直至第 n 层时终止分裂。 # 空间复杂度 空间复杂度用户衡量 算法使用的内存空间随着数据量变大时的增长趋势。 通常情况下，空间复杂度统计范围是「暂存空间」+ 「输出空间」。 暂存空间进一步划分为： 「暂存数据」保存算法运行过程中的各种常量、变量、对象 「栈帧空间」用于保存调用函数的上下文数据。 「指令空间」用于保存编译后的程序指令，在实际统计中通常忽略不计。 因此，在分析一段程序的空间复杂度时，一般统计：暂存数据、输出数据、栈帧空间三部分。 # 推算方法 与时间复杂度大致相同。只是将统计对象从 计算操作数量 转为 使用空间大小 。不同的是，通常只关注「最差空间复杂度」（因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留） # 空间复杂度常见类型 常数阶 对数阶 线性阶 平方阶 指数阶 # 常数阶 常见于数量与输入数据大小无关的常量、变量、对象。（在循环中初始化变量或调用函数而占用的内存，在进入下一一循环后就会释放，不会累积占用空间，空间复杂度仍为 O (1)） 12345678910111213141516/* 常数阶 */function constant(n) { // 常量、变量、对象占用 O(1) 空间 const a = 0; const b = 0; const nums = new Array(10000); const node = new ListNode(0); // 循环中的变量占用 O(1) 空间 for (let i = 0; i &lt; n; i++) { const c = 0; } // 循环中的函数占用 O(1) 空间 for (let i = 0; i &lt; n; i++) { constFunc(); }} # 线性阶 常见于元素数量与 n 成正比的数组、链表、栈、队列等。 ??? 1234567891011121314151617181920212223/* 线性阶 */function linear(n) { // 长度为 n 的数组占用 O(n) 空间 const nums = new Array(n); // 长度为 n 的列表占用 O(n) 空间 const nodes = []; for (let i = 0; i &lt; n; i++) { nodes.push(new ListNode(i)); } // 长度为 n 的哈希表占用 O(n) 空间 const map = new Map(); for (let i = 0; i &lt; n; i++) { map.set(i, i.toString()); }}// 以下递归函数会同时存在 n 个未返回的 algorithm() 函数，使用 O(n) 大小的栈帧空间。/* 线性阶（递归实现） */function linearRecur(n) { console.log(`递归 n = ${n}`); if (n === 1) return; linearRecur(n - 1);} # 平方阶 常见于矩阵和图，元素数量与 n 成平方关系。 # 指数阶 指数阶常见于 二叉树 。高度为 n 的「满二叉树」的节点数量为 2^n - 1，占用 O (2^n) 空间。 123456789/* 指数阶（建立满二叉树） */function buildTree(n) { if (n === 0) return null; const root = new TreeNode(0); root.left = buildTree(n - 1); root.right = buildTree(n - 1); return root;} # 对数阶 常见于分治算法和数据类型转换 # 4. 数据结构 # 数据结构分类 # 逻辑结构：线性与非线性 非线性数据结构进一步划分：树形结构和网状结构。即： 线性结构：数组、链表、队列、栈、哈希表，元素存在一对一的顺序关系。 非线性结构： 树形结构：树、堆、哈希表，元素存在一对多的关系。 网状结构：图，元素存在多对多的关系 # 物理结构：连续与离散 见 hello 算法 # 5. 数组与链表 # 数组 「数组 Array」是线性结构，其将相同类型元素存储在连续的内存空间中。我们将在数组中的位置成为「索引 Index」 # 数组优点 在数组中访问元素非常高效。由于数组元素被存储在连续的内存空间中，计算数组元素的内存地址很容易。给定首尾元素的索引，可以使用以下公式计算该元素的内存地址，从而直接访问此元素。 123// 元素内存地址 = 数组内存地址 + 元素长度 * 元素索引elementAddr = firtstElementAddr + elementLength * elementIndex ::: 为什么数组元素的索引要从 0 开始编号？ 观察上图，我们发现数组首个元素的索引为 0，这似乎有些反直觉，因为从 1 开始计数会更自然。 然而，从地址计算公式的角度看，索引本质上表示的是内存地址的偏移量。首个元素的地址偏移量是 0 ，因此索引为 0 也是合理的。 ::: 因为访问元素非常高效，所以可以在 O (1) 时间内获取数组的任一元素。 arr[index] # 数组缺点 数组在初始化后长度不可变。系统无法保证数组之后的内存空间是否可用，因此数组长度无法扩展，如若希望扩容数组，需新建数组，然后一次拷贝过去，数组很大时则会很耗时。 ::: 请注意，JavaScript 的 Array 是动态数组，可以直接扩展 为了方便学习，将 Array 看作是长度不可变的数组 ::: 总结，数组的插入与删除操作有以下缺点： 时间复杂度高：数组的插入和删除的平均时间复杂度均为 O (n) ，其中 n 为数组长度。 丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。 内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是我们不关心的，但这样做同时也会造成内存空间的浪费。 # 6. 栈与队列 # 7. 散列表 # 8. 树 # 9. 堆","link":"/blog/2023/04/20/hello%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"栈数据结构","text":"# 栈是一种遵从先进后出原则的有序结合。 新添加的或待删除的元素都保存在栈的同一端，为栈顶，另一端则为栈底。且新元素都靠近栈顶，旧元素都接近栈底。 例：一摞书、堆起的盘子 # 创建一个类来表示栈： 123function Stack { // 属性和方法} # 选择一种数据结构保存栈里的元素（这里选择数组）： 1let items = [] 声明一些需要用到的一些方法 push pop peek isEmpty clear size 向栈中添加元素（只向栈中的末尾即栈顶添加） 123this.push = function(ele) { items.push(ele)} 移出栈中的元素（移出末尾即栈顶） 123this.pop = function() { return items.pop()} 查看栈顶元素、检查栈是否为空、清空栈、打印栈元素 123456789101112131415this.peek = function() { return items[items.length - 1]}this.isEmpty = function() { return item.length === 0}this.clear = function() { items = []}this.print = function() { console.log(items.toString())} # 使用 Stack 类 1234567let stack = new Stack() // []console.log(stack.isEmpty()) // truestack.push(2) // [2]stack.peek() // 2 # es6 改造此类 123456789class Stack { constructor() { this.items = [] } push(ele) { this.items.push(ele) } ...} es6 创建的类基于原型，比基于函数的节省内存，更适合创建多个实例。但是不能声明私有属性，此处的 items 是公共的。 # 再改造（利用 es6 的限定作用域 Symbol 实现） es6 新增的 Symbol 的基本类型，不可变，可以用作对象的属性 1234567891011let _items = Symbol()class Stack() { constructor() { this[_items] = [] } push(ele) { this[_items].push(ele) } ...} 缺点: _items 属性是个数组，可以进行任意的数组操作，例如从中间删除和添加。栈中不该有这种行为 # 再次改造（WeakMap 数据类型）（可确保属性是私有的） 12345678910111213141516171819202122232425262728const items = new WeakMap()class Stack { constructor() { items.set(this, []) } push(ele) { let s = items.get(this) s.push(ele) } pop() { let s = items.get(this) let r = s.pop() return r } ...}// 利用闭包把stack类包起来let stack = (function() { const items = new WeakMap() class Stack { constructor() { items.set(this, []) } } ... // 其他方法 return Stack})()","link":"/blog/2020/03/25/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%85%A0/"},{"title":"koa实现基础爬虫","text":"# koa 基础初步使用 Koa 由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 没有捆绑任何中间件， 而是提供了一套优雅的方法去编写服务端应用程序 # 安装、启动服务 12npm initnpm install koa 123456const koa = require('koa')const app = new koa()// 启动服务 端口为3000app.listen(3000)// 使用node app命令启动服务 这样每次修改文件都需要重新启动服务，可以使用 nodemon 监听文件变化自动重启 npm install nodemon -g 然后启动服务时，使用 nodemon app.js # 响应返回 1234567891011const koa = require('koa')const app = new koa()app.use(async ctx =&gt; { ctx.body = 'Hello World';})// 启动服务 端口为3000// 浏览器访问locahost:3000 返回hello worldapp.listen(3000) # 使用 koa-router 插件管理路由 为 koa 设计的路由中间件，路由由 url 生成 12345678910111213141516const koa = require('koa')const app = new koa()// 引入路由、实例化const router = require('koa-router')()router.get('/api/testapi', async ctx =&gt; { // const data = await fetchData() const data = '这是从testapi返回出去的数据' ctx.body = data})app.use(router.routes())app.use(router.allowedMethods())// 浏览器访问locahost:3000/api/testapiapp.listen(3000) # 爬取数据 # 安装插件、首次完整抓取 12# 安装所需插件npm install superagent cheerio superagent-charset 1234567891011121314151617181920212223242526const koa = require('koa')const app = new koa()const router = require('koa-router')()// 引入插件const charset = require('superagent-charset')const superagent = require('superagent')charset(superagent)const cheerio = require('cheerio')superagent.get('https://s.weibo.com/top/summary?cate=realtimehot') .charset() .end((err, sres) =&gt; { const html = sres.text console.log(html) })router.get('/api/testapi', async ctx =&gt; { const data = '这是从testapi返回出去的数据' ctx.body = data})app.use(router.routes())app.use(router.allowedMethods())app.listen(3000) 此时启动服务，就会去访问微博热搜页面，命令行中打印页面源码说明爬取成功 # 分析节点源码，处理数据 1234567891011121314151617181920const $ = cheerio.load(html)let hotList = []$(&quot;#pl_top_realtimehot table tbody tr&quot;).each(function(index) { if (index !== 0) { const $td = $(this).children().eq(1); const link = 'https://s.weibo.com' + decodeURI($td.find(&quot;a&quot;).attr(&quot;href&quot;)); const text = $td.find(&quot;a&quot;).text(); const hotValue = $td.find(&quot;span&quot;).text(); const icon = $td.find(&quot;img&quot;).attr(&quot;src&quot;) ? &quot;https:&quot; + $td.find(&quot;img&quot;).attr(&quot;src&quot;) : &quot;&quot;; hotList.push({ sort: index, link, text, hotValue, icon, }) }}) # 前端请求数据、查看接口返回 本地环境中，koa 服务需要设置 cors 以允许跨域访问 使用 koa-router 管理请求 1npm install koa2-cors koa-router --save 12345678910111213141516171819202122const Koa = require('koa')const app = new Koa()const router = require('koa-router')();// 设置允许跨域访问服务const cors = require('koa2-cors')app.use(cors())- app.use(async ctx =&gt; {- const data = await getSinaData()- ctx.body = data- })+ router.get('/api/getSinaHotSearchList', async ctx =&gt; {+ const data = await getSinaData()+ ctx.body = data+ })app.listen(3000, () =&gt; { console.log(`success and it is listening at port 3000`)}) 页面接口请求、查看返回数据 12345fetch.get('http://localhost:3000/api/getSinaHotSearchList') .then(response =&gt; response.json()) .then(res =&gt; { console.log(res) })","link":"/blog/2020/09/08/koa%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB/"},{"title":"nodejs实战笔记-常用功能","text":"# 创建静态文件服务器 # 所需模块 123456var http = require('http')var fs = require('fs')var path = require('path')var mime = require('mime') // 附加的mime模块 有根据文件扩展名得出mime类型的能力var cache = {} # 工具函数 1234567891011121314// 错误数据function send404(response) { response.writeHead(404, { 'Content-Type': 'text/plain' }) response.write('Error 404: resource not found') response.end()}// 文件数据function sendFile(response, filePath, fileContents) { response.writeHead( 200, { 'Content-Type': mime.lookup(path.basename(filePath)) } ) response.end(fileContents)} # 提供静态服务 访问内存 (ram) 要比访问文件系统快很多，node 程序中通常会把常用的数据缓存到内存里。 只有第一次访问的时候需要从文件系统中读取 123456789101112131415161718192021function serveStatic(response, cache, absPath) { if (cache[absPath]) { sendFile(response, absPath, cache[absPath]) } else { fs.exists(absPath, function(isExist) { if (isExist) { fs.readFile(absPath, function(err, data) { if (err) { send404(response) } else { // 从硬盘中读取文件并返回 cache[absPath] = data sendFile(response, absPath, data) } }) } else { send404(response) } }) }} # 创建 http 服务器 1234567891011121314var server = http.createServer(function(request, response) { var filePath = false if (request.url == '/') { filePath = 'public/index.html' } else { // 将url路径转为文件的相对路径 filePath = 'public' + request.url } var absPath = './' + filePath serveStatic(response, cache, absPath)})server.listen(3000)","link":"/blog/2020/03/28/nodejs%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"title":"nodejs实战笔记-mysql的基本使用","text":"连接 12345678const mysql = require('mysql')const db = mysql.createConnection({ host: '127.0.0.1', user: 'root', password: 'root', database: 'myblog'}) 创建数据库表 12345678910111213db.query( `CREATE TABLE IF NOT EXISTS work ( id INT(10) NOT NULL AUTO_INCREMENT, hours DECIMAL(5,2) DEFAULT 0, date DATE, desc LOGGTEXT, PRIMARY KEY(id))`, function(err) { if (err) throw err console.log('server started') server.listen(3000, '127.0.0.1') }) 常用操作 123456789101112131415161718192021222324252627exports.add = (db, req, res) =&gt; { db.query( `ININSERT INTO work (hours, date, desc) VALUES (?,?,?) [hoursVal,dateval,descVal]` )}exports.delete = (db, req, res) =&gt; { db.query( ` DELETE FROM work WHERE id=? [idVal] ` )}exports.show = (db, req, curId) =&gt; { const query = ` SELECT * FROM work WHERE archived=? ORDER BY date DESC ` const curId = curId ? 1 : 0 db.query( query, [curId] )}","link":"/blog/2020/04/24/nodejs%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%8Bmysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"nodejs实现单线程高并发原理","text":"# 前言 在我接触 Nodejs 的时候，听的最多的关键字就是：事件驱动、非阻塞 I/O、高效、轻量，是单线程且支持高并发的脚本语言。可为什么单线程的 nodejs 可以支持高并发呢？很多人都不明白其原理，自己也在很长一段时间内被这些概念搞的是云里雾里。下面我们就来一步一步揭开其神秘的面纱。并且，通过底层 C/C++ 源码的学习，来剖析 Nodejs 实现高并发的之一 ------ 事件循环的实现。 # 从 Node.js 进入我们的视野时，我们所知道的它就由这些关键字组成 事件驱动、非阻塞 I/O、高效、轻量，它在官网中也是这么描述自己的。 于是在我们刚接触 Nodejs 时，会有所疑问： 为什么在浏览器中运行的 Javascript 能与操作系统进行如此底层的交互？ nodejs 真的是单线程吗？ 如果是单线程，他是如何处理高并发请求的？ nodejs 事件驱动是如何实现的？ # 架构一览 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。 Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。 Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。 Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。 C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。 # 与操作系统交互 举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码： 1234var fs = require('fs');fs.open('./test.txt', &quot;w&quot;, function(err, fd) { //..do something}); 这段代码的调用过程大致可描述为：lib/fs.js → src/node_file.cc → uv_fs 12345678910111213141516171819202122232425262728293031323334353637lib/fs.jsasync function open(path, flags, mode) {mode = modeNum(mode, 0o666);path = getPathFromURL(path);validatePath(path);validateUint32(mode, 'mode');return new FileHandle(await binding.openFileHandle(pathModule.toNamespacedPath(path),stringToFlags(flags),mode, kUsePromises));}src/node_file.ccstatic void Open(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {Environment* env = Environment::GetCurrent(args);const int argc = args.Length();if (req_wrap_async != nullptr) { // open(path, flags, mode, req)AsyncCall(env, req_wrap_async, args, &quot;open&quot;, UTF8, AfterInteger,uv_fs_open, *path, flags, mode);} else { // open(path, flags, mode, undefined, ctx)CHECK_EQ(argc, 5);FSReqWrapSync req_wrap_sync;FS_SYNC_TRACE_BEGIN(open);int result = SyncCall(env, args[4], &amp;req_wrap_sync, &quot;open&quot;,uv_fs_open, *path, flags, mode);FS_SYNC_TRACE_END(open);args.GetReturnValue().Set(result);}}uv_fs/* Open the destination file. */dstfd = uv_fs_open(NULL,&amp;fs_req,req-&gt;new_path,dst_flags,statsbuf.st_mode,NULL);uv_fs_req_cleanup(&amp;fs_req); 具体来说，当我们调用 fs.open 时，Node.js 通过 process.binding 调用 C/C++ 层面的 Open 函数，然后通过它调用 Libuv 中的具体方法 uv_fs_open，最后执行的结果通过回调的方式传回，完成流程。我们在 Javascript 中调用的方法，最终都会通过 process.binding 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。 # 为什么一个单线程的效率可以这么高，同时处理数万级的并发而不会造成阻塞呢？就是我们下面所说的 -------- 事件驱动。 每个 Node.js 进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。 主线程之外，还维护了一个 &quot;事件队列&quot;（Event queue）。当用户的网络请求或者其它的异步操作到来时，node 都会把它放到 Event Queue 之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。 主线程代码执行完毕完成后，然后通过 Event Loop，也就是事件循环机制，开始到 Event Queue 的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交 EventLoop 处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。 主线程不断重复上面的第三步。 我们所看到的 node.js 单线程只是一个 js 主线程，本质上的异步操作还是由线程池完成的，node 将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的 I/O 操作，从而实现异步非阻塞 I/O，这便是 node 单线程和事件驱动的精髓之处了 原文链接","link":"/blog/2020/09/04/nodejs%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"},{"title":"nuxt2.x小结","text":"使用之前先撸遍官方文档 # 绝多部分问题，都可以在网上搜得到，所以整体开发还算顺利，难度一般，以下纪录本人项目中用到和总结的一些知识，后面有新的问题会更新，欢迎讨论！ # 路由守卫 使用nuxt的middleware功能，中间件允许一个函数在每个页面进入之前运行 可以在页面中使用/可以全局使用 12345678910111213141516// middleware/route.js// 接收context作为第一个参数export default ({ route, redirect, app, store }) =&gt; { if (!store.state.userInfo.userId) { return redirect('/login') } if (route.fullPath === '/mine') { return redirect('/mine/account') }}// nuxt.config.js中配置module.exports = { router: { middleware: 'route' }} # 自定义全局方法 用到nuxt中的plugins功能 nuxt在运行程序之前执行js插件（适用自己的库或第三方模块,修改plugin时需要重启项目） 此处封装localstorge操作 // 只允许mounted之中调用 123456789101112131415161718192021222324252627282930313233343536373839// /plugins/utils.jsimport Vue from 'vue'const storge = { install(Vue) { /** * @params key setItem key * @params value setItem value * @params expire 过期时间&lt;number&gt; 默认7 */ Vue.prototype.$setStorge = (key, value, expire = 7) =&gt; { let obj = { value, time: Date.now(), expire: expire * 60 * 60 *24 } localStorage &amp;&amp; localStorage.setItem(key, JSON.stringify(obj)) } Vue.prototype.$getStorge = (key) =&gt; { let val = localStorage.getItem(key) if (!val) return null val = JSON.parse(val) // 过期 if ((Date.now() - val.time) &gt; val.expire) { localStorage.removeItem(key) return null } return val.value } Vue.prototype.$delStorge = (key) =&gt; { localStorage.removeItem(key) } }}Vue.use(storge)// nuxt.config.js中需配置plugins字段，参考middleware # nuxt 中使用 vuex store目录中新建user.js 直接暴露state等属性 不使用模块化，直接新建index.js 暴露 123456789101112131415export const state = () =&gt; ({ userInfo: null})export const mutations = { setUserInfo(state, data) { state.userInfo = data }}export default { state, // getters, // actions, mutations} # 服务端获取数据 asyncData方法 页面级组件中服务端才会生效的钩子 页面刷新时不执行 return 出去的对象会放入到客户端中的 data 数据中 1nuxtServerInit 获取服务端数据 可访问到服务端的 context 对象 只存在于 vuex 中 12nuxt会在每一次请求服务器页面时执行，即：首次进入页面或刷新页面且只存在于vuex中的action对象中 1234567891011// vuex中记录获取cookie记录登录状态export const actions = { nuxtServerInit({ commit }, { req }) { try { let cookies = req.headers['cookie'] console.log(cookies) } catch (error) { console.log(error) } }} # 页面或全局引用 script 链接 12345678// 组件或nuxtconfigjsexport default { head: { script: [ { src: '***' } ] }} # 动态设置页面 title 及 meta 信息 12345678910export default { head() { return { title: '***'， meta: { hid: 'description', name: 'description', content: '***' } } }} # nuxt 部署 服务端安装工具 node、yarn、pm2 1234curl --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash -sudo yum install -y nodejssudo yum install yarnnpm install -g pm2 本地 nuxt 项目代码执行 npm run build（.nuxt 文件夹下会生成 dist 文件目录） 把.nuxt、static、nuxt.config.js、package.json server 五个文件夹拖到服务器上 服务器上安装依赖 npm install 启动项目 npm run start 启动进程守护 pm2 start npm --name “package.json 文件中得 name” – run start # 第一次部署时出错 12345678910- Unexpected identifier // 意外的识别码(function (exports, require, module, __filename, __dirname) { import Modal from './confirm' })// 很多说的是项目中缺少识别import引入方式的babel// 按照参考下载了也没用// 找不到解决方法, 后来发现，iview的按需引入处的错误// package.json中的iview版本为3.15也就是iview// 而按需引入中的包名使用'iview'就会报错// 改为'view-design'解决 123456&quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;view-design&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; }]] # nginx 部分配置 123location / { proxy_pass http://localhost:3000;} # 引入百度统计代码 新建 plugins/baidu.js 1234567891011export default ({app: {router}, store}) =&gt; { /* 每次路由变更时进行pv统计 */ router.afterEach((to, from) =&gt; { /* 告诉增加一个PV */ try { window._hmt = window._hmt || [] window._hmt.push(['_trackPageview', to.fullPath]) } catch (e) { } })} 123script: [ { src: 'https://hm.baidu.com/hm.js?****' }] nuxt.config.js 中配置 plugins 字段 # 开启 https nuxt.config.js 中的 server 字段 123456789101112const path = require('path')const fs = require('fs')module.exports = { server: { https: { // 此处路径可以直接写死 读取https证书文件 // key: fs.readFileSync(path.resolve(__dirname, '**server.key')) key: fs.readFileSync('/usr/local/***.key') } }}","link":"/blog/2020/01/22/nuxt2-x%E5%B0%8F%E7%BB%93/"},{"title":"nuxt部署","text":"服务器: centos7.6 版本 # 安装 nginx 不怎么懂各种操作的意思，网上有很多参考文章。https://www.cnblogs.com/bluestorm/p/4574688.html nginx 配置 1234567891011server { listen 8000; # listen somename:8080; server_name localhost; location /admin { // 访问ip:8080/admin 时会出现/var/www/admin下的indexhtml文件 # root html; alias /var/www/admin; index index.html index.htm; }} 安装 nodejs、yarn、pm2 12345678url --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash - // 下载源文件sudo yum install -y nodejs // 安装nodejs (node -v)sudo yum install yarn // 安装yarnnpm install -g pm2 本地 nuxt 项目代码执行 npm run build (.nuxt 文件夹下会生成 dist 文件目录) 把 .nuxt、static、nuxt.config.js 、package.json 四个文件夹复制到服务器上 服务器上 执行 npm install -production（生产环境安装依赖） npm run start （开启 node 服务）（若缺失什么文件会有提示，再复制过去即可） 此时正常情况下，网站已经可以访问。退出 xshell 后，就会报错（缺少 pm2 进程守护） pm2 start npm --name “package.json 文件中的 name” – run start # 问题 公司服务器上安装 nodejs 的时候 执行 curl 和 install 两步后 node -v 查看版本后 没有出现版本号 试了很多次，都没有成功，最后 到 /etc/yum.repos.d 下关于 nodesource… 的文件有两个，全部手动删除 重新执行 curl 和 install 那两步后 node -v npm -v 成功安装 # pm2 常用命令 1234567- pm2 list 查看所有启动的应用程序- pm2 show app-name 查看某app所有信息- pm2 delete all 删除所有- pm2 stop 0 停止指定id的应用 # 目前更新项目： 12345678npm run build 后 把那五个文件夹放到服务器上之后 需要重启node服务ps aux | grep node 查看node进程 sudo kill -9 &lt;进程号&gt;目录下启动服务 npm run start目录下开启进程守护 pm2 start npm --name &quot;package.json文件中的name&quot; -- run start","link":"/blog/2020/03/22/nuxt%E9%83%A8%E7%BD%B2/"},{"title":"serverless","text":"参考一 参考二 前端开发模式的技术表格即技术演进 serverless 常见服务商提供的解决方案 基于 serverless 的前端开发模式 # 前端开发模式的演进 基于 php/java 的模板渲染的动态页面 基于 ajax 的前后端分离模式 基于 nodejs 的前端工程化 基于 nodejs 的全栈开发 # 模板渲染 在早起的互联网时代，我们的网页很简单，就是一些静态或动态的页面，主要目的是用来做信息的展示和传播。这个时候开发一个网页也很 easy，主要就是通过 JSP、PHP 等技术写一些动态模板，然后通过 Web Server（nginx，apache） 将模板解析成一个个 HTML 文件，浏览器只负责渲染这些 HTML 文件。这个阶段还没有前后端的分工，通常是后端工程师顺便写了前端页面。 JSP: Java Server Page: Java 服务端页面，在 html 页面中编写 Java 代码的页面 WebServer：网站服务器或 web 服务器 # ajax 2005 年 AJAX 技术的正式提出，翻开了 Web 开发的新篇章。基于 AJAX，我们可以把 Web 分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理。前后端通过接口进行数据交互。我们也不再需要在各个后端语言里面写着难以维护的 HTML。网页的复杂度也由后端的 Web Server 转向了浏览器端的 JavaScript。也正因如此，开始有了前端这个职位 # nodejs 工程化 2009 年 Node.js 的出现，对于前端来说，也是一个历史性的时刻。随着 Node.js 一同出现的还有 CommonJS 规范和 npm 包管理机制。随后也出现了 Grunt、Gulp、Webpack 等一系列基于 Node.js 的前端开发构建工具。 在 2013 年前后，前端三大框架 React.js/Angular/Vue.js 相继发布第一个版本。我们可以从以往基于一个个页面的开发，变为基于一个个组件进行开发。开发完成后使用 webpack 等工具进行打包构建，并通过基于 Node.js 实现的命令行工具将构建结果发布上线。前端开发开始变得规范化、标准化、工程化。 # nodej 全栈开发 Node.js 对前端的重要意义还有，以往只能运行在浏览器中的 js 也可以运行在服务器上，前端可以用自己最熟悉的语言来写服务端的代码。于是前端开始使用 Node.js 做全栈开发，开始由前端向全栈的方向转变。这是前端主动突破自己的边界。 另一方面，前端在发展，后端也在发展。也差不多在 Node.js 诞生那个时代，后端普遍开始由巨石应用模式向微服务架构转变。这也就导致以往的前后端分工出现了分歧。随着微服务架构的兴起，后端的接口渐渐变得原子性，微服务的接口也不再直接面向页面，前端的调用变得复杂了。于是 BFF（Backend For Frontend）架构出现了，在微服务和前端中间，加了一个 BFF 层，由 BFF 对接口进行聚合、裁剪后，再输出给前端。而 BFF 这层不是后端本质工作，且和前端的关系最大，所以前端自然而然选择了 Node.js 来实现。这也是当前 Node.js 在服务端较为广泛的应用的原因。 巨石应用 大部分 web 工程是将所有的功能模块 (service side) 打包到一起并放在一个 web 容器中运行，很多企业的 Java 应用程序打包为 war 包 微服务架构 微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。 # serverless CNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年 7 月 21 日（于美国波特兰 OSCON 2015 上宣布），其最初的口号是坚持和整合开源技术来让编排容器作为微服务架构的一部分，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。 目前行业可能更多处在容器 Docker+Kubernetes, 利用 IaaS、PaaS 和 SaaS 来快速搭建部署应用 基础架构即服务（Infrastructure as a Service，IaaS）、平台即服务（Platform as a Service，PaaS）以及软件即服务（Software as a Service，SaaS）。 Docker 是一个平台，它主要是提供一些服务，任何一台装有 docker 的机器你都可以建立、发布、运行你的应用程序，使用 docker 很省钱省时。 简单的介绍 Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes 定位在 Paas 层，重点解决了微服务大规模部署时的服务编排问题。 # 其实 Serverless 早已和前端产生了联系，只是我们可能没有感知 CDN: 相信大家都使用过 CDN，我们开发完成之后，直接将静态文件部署到 CDN 上，通过 CDN 进行内容分发、网络加速，在这个过程中，前端不需要关心 CDN 有多少个节点、如何做负载均衡，也不需要知道 CDN 的 QPS 是多少。所以从这个角度来说，CDN 是一种 serverless 的实现。 再比如对象存储，和 CDN 一样，我们只需要将文件上传到对象存储，就可以直接使用了，不需要关心它如何存取文件、如何进行权限控制，所以对象存储对前端来说是 Serverless。 甚至一些第三方的 API 服务，也是 Serverless，因为我们使用的时候，不需要去关心服务器。 当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合 简单来讲，FaaS（Function as a Service） 就是一些运行函数的平台，比如阿里云的函数计算、AWS 的 Lambda 等。 BaaS（Backend as a Service）则是一些后端云服务，比如云数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。 Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。 # Serverless 的主要特点 事件驱动 ---- 函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。 无状态 ---- 因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 Redis 等。 Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value [数据库]，并提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从 2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。 无运维 ---- 使用 serverless 我们不需要关心服务器，也不需要关心运维，这也是 serverles 思想的核心； 低成本 ---- 使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源过度 # 常见服务商提供的解决方案 1、上图是当前主要的一些 Serverless 服务，以及对应的服务解决方案。 2、从下往上，分别是基础设施、开发工具和应用场景。 亚马逊 - 微软 - 谷歌 3、基础设施主要是一些云计算厂商提供，包括云计算平台和各种 BaaS 服务，以及运行函数的 FaaS 平台。 前端主要是 Serverless 的使用者，所以对前端来说，最重要的开发工具这一层，我们需要依赖开发工具进行 Serverless 开发、调试和部署。 4、框架（Framework） 如今还没有一个统一的 Serverless 标准，不同云计算平台提供的 Serverless 服务很可能是不一样的，这就导致我们的代码，无法平滑迁移。Serverless 框架一个主要功能是简化 Serverless 开发、部署流程，另一主要功能则是屏蔽不同 Serverless 服务中的差异，让我们的函数能够在不改动或者只改动很小一部分的情况下，在其他 Serverless 服务中也能运行。常见的 Serverless 框架有 Serverless Framework、ZEIT Now、Apex 等。不过这些基本都是国外公司做的，国内还没有这样的平台。 5、Web IDE 和 Serverless 紧密相关的 Web IDE 主要也是各个云计算平台的 Web IDE。利用 Web IDE，我们可以很方便地在云端开发、调试函数，并且可以直接部署到对应的 FaaS 平台。这样的好处是避免了在本地安装各种开发工具、配置各种环境。常见的 Web IDE 有 AWS 的 Cloud9、阿里云的函数计算 Web IDE、腾讯云的 Cloud Studio。 6、当然，目前最主要的开发方式还是在本地进行开发。所以在本地开发 Serverless 的命令行工具也必不可少。 命令行工具主要有两类，一类是云计算平台提供的，如 AWS 的 aws、 Azure 的 az、阿里云的 fun；还有一类是 Serverless 框架提供的，如 serverless、now。 大部分工具如 serverless、fun 等，都是用 Node.js 语言来实现的。 7、应用场景 在开发工具上面一层，则是 Serverless 的一些垂直应用场景。除了使用传统的服务端开发，目前使用 Serverless 技术的还有小程序开发，未来可能还会涉及到物联网领域（IoT）。 # 未来前端 在传统开发流程中，我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题 基于 Serverless，后端变得非常简单，以往的后端应用被拆分为一个个函数，只需要写完函数并部署到 Serverless 服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。 当然，前端基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发。 # 使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。","link":"/blog/2020/04/01/serverless/"},{"title":"vuepress","text":"# 首页 以此站为例，介绍使用 vuepress 搭建博客过程 # 全局安装 123npm install -g vuepress# oryarn global add vuepress # 博客目录 新建 docs 文件夹，docs 文件夹中新建.vuepress 文件夹和 README.md 文件 当前目录生成 package.json 文件 1234567# 1mkdir docscd docsmkdir .vuepressecho &quot;# hello vuepress&quot; &gt; README.md# 2npm init -y # 当前目录文件结构 123456vuepress-demo├── package.json└── docs ├── .vuepress │ └── config.js # 配置 ├── README.md # 首页文件 # 修改 package.json 文件 添加执行脚本 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;vuepress dev docs&quot;, &quot;build&quot;: &quot;vuepress build docs&quot;} # 开发环境运行 1npm run dev # 访问本地端口页面为/docs/README.md文件内的内容 # configjs 配置 12345678910module.exports = { title: '博客', description: '嘎嘣跳的博客', nav: [ { text: '关于', link: 'https://laine001.github.io' } ], sidebar: [ '/' ]} 重启项目，可以看到 title 和 desc。头部右侧多了一个关于选项 # 打包 1npm run build # 跟目录会生成.vuepress文件夹","link":"/blog/2019/10/23/vuepress/"},{"title":"vuex的使用","text":"使用场景 多个视图依赖于同一状态 来自不同视图的行为需要变更这个同一状态 核心概念 12345state // 记录状态即多个组件依赖的变量getter // 相当于单个组件中使用的computed属性，获取state时使用mutation // 更改state中的状态action // 提交mutation操作、异步操作module // 分模块使用store 使用步骤 1234567891011121314151617181920212223242526272829// 登录后存取用户信息及组件中取用或改变state信息// 定义state中的属性const Store = new Vuex.Store({ state: { username: '' }, // 可用可不用 getters: { username(state) { return state.username } }, // 提交改变的为一属性 mutations: { setUsername(state, value) { state.username = value } }, actions: { // setUsernameAsync(state, value) { // state.commit('setUsername', value) // } // 触发mutations中的方法，可做异步操作 setUsernameAsync({ commit }, value) { commit('setUsername', `${value}001`) } }}) 123456789101112131415// 视图中提交改变和取用// 登录后设置username的值this.$store.dispatch('setUsername', 'laine') // 直接提交mutations中的方法改变或this.$store.commit('setUsernameAsync', 'laine') // 通过commit方法触发actions中的方法// 其他组件中取用state中的值this.username = this.$store.state.username或impot { mapGetters } from 'vuex'computed: { ...mapGetters(['username'])} vuex 存储状态不是持久的即刷新页面会清除所有状态 解决方法： 每次提交改变或设置改变时 利用本地存储保存 store 中写入插件 vuex-persist 1npm install vuex-persist -S 1234567import VuexPersistence from 'vuex-persist'const vuexLocal = new VuexPersistence({ storage: window.localStorage})// 和state、getters等同级plugins: [vuexLocal.plugin]","link":"/blog/2019/08/26/vuex/"},{"title":"Vue中使用mock","text":"配置 mock 之前需配置好 axios 1npm install mock 基础使用（单独页面中使用） 1&lt;button @click=&quot;getData&quot;&gt; 生成数据 &lt;/button&gt; 12345678910111213141516171819import Mock from 'mockjs' // node方式引入 (CommonJS)export default { name: 'HelloWorld', data() { return { mockData: [] // 生成数据 } }, methods: { getRandom () { this.mockData = Mock.mock({ //生成数据规则 'list|1-10': [{ 'id|+1': 1 }] }) document.body.innerHTML += '&lt;pre&gt;' + JSON.stringify(this.mockData, null, 4) + '&lt;/pre&gt;' // 展示到页面中 } } 全局配置 配置好的 requestjs 文件中 12345678910111213141516171819202122232425262728293031323334353637import axios from 'axios'// axios.defaults.headers.post['Content-Type'] = 'application/x-www-urlencoded'const http = axios.create()http.defaults.timeout = 3000http.interceptors.request.use(config =&gt; { // 请求拦截器配置 // 可不配置 // do sth return config}, error =&gt; { console.log(error) return Promise.reject(error)})http.interceptors.response.use(response =&gt; { // 响应拦截器配置 // 可不配置 // do something return response}, error =&gt; { console.log(error) return Promise.reject(error)})export function fetch(url, params) { // 封装axios的post请求 return new Promise((resolve, reject) =&gt; { // promise 用法,自行查阅 axios.post(url, params).then(response =&gt; { resolve(response.data) // promise相关 }).catch(error =&gt; { reject(error) // promise相关 }) })}export default { // 暴露htto_mock方法，即后面页面中用到的方法 http_mock(url, params) { return fetch(url, params) }} 然后配置 mockjs 1234567891011121314151617181920import Mock from 'mockjs'const Random = Mock.Randomvar listData = function() { let _data = [] for (let i = 0; i &lt; 20; i++) { let newList = { // 详细 规则 参照mockjs官网 title: Random.csentence(5, 30), // Random.csentence( min, max ) imgSrc: Random.dataImage('200x160', '这是图片中的文本'), // Random.dataImage( size, text ) 生成图片（base64位数据格式） author_name: Random.cname(), // Random.cname() 随机生成中文名 date: Random.date() + ' ' + Random.time() // Random.date()指示生成的日期字符串的格式,默认为yyyy-MM-dd；Random.time() 返回一个随机的时间字符串 } _data.push(newList) } return {_data: _data}}// url为要拦截的请求地址 请求方式 请求数据（规则） （此处api会被mockjs拦截）Mock.mock('http://route.showapi.com/60-27', 'post', listData) mainjs 中引入即可 1import request from '@/http/request' 最后就是页面中使用了 1234567891011// import request from '@/http/request' // 页面中引入配置好的api请求created () { this.getData()},method: { getData() { // 假装要使用http_mock发送请求（#手动滑稽#）（mock自动拦截请求并生成数据） request.http_mock('http://route.showapi.com/60-27','api_id=63114&amp;api_sign=3847b0').then(response =&gt; { console.log(response._data) } } } 完事其他页面中引入下就能使用了，后台接口对接好之后，mockjs 直接取消使用就 ok 了","link":"/blog/2019/02/02/vue%E4%B8%AD%E4%BD%BF%E7%94%A8mock/"},{"title":"vue中使用ts入门","text":"# 为什么使用 typescript 支持所有原生 javscript 的语法 类型检查。使 js 具有强类型语言的特性 vscode 支持友好 微软开源，各大框架源码等皆开始使用 ts 开发 # vue 中使用 typescript vue create ts-demo 时选择 Typescript、class-style 的语法 下载 vue-class-component、vue-property-decorator 插件 # ts 基础使用 官方快速上手教程","link":"/blog/2020/06/16/vue%E4%B8%AD%E4%BD%BF%E7%94%A8ts%E5%85%A5%E9%97%A8/"},{"title":"解决vue项目打包vendorjs文件过大","text":"项目上线后，浏览器第一次加载会特别特别慢，network 中看到 vendorjs 文件 1.9M，不慢才怪。 echarts 按需引入后，也有 1.1M 左右，由于对 vuecli (2.x) 理解不深，自己扒了大量的文档，又测试了很多次，才测试成功，暂时简单记录下。 12//可以查看项目文件大小分析npm run build --report app.js 存放页面中的 js 操作，使用路由的按需加载，可把 app.js 分隔成多个小的 js 文件 此时分隔好的 js 文件要看各页面中的业务代码量，其中我这里单独的一个图表页还是很大， 800k 左右，又是 echarts 的锅。暂时放这。 vendorjs 中是项目中所有引用的依赖包，即使用的 vue、eleui、axios 等等插件框架什么的都在这里边，怪不得大。 参考文档，找到以下解决方法： cdn 引入插件 打包时使用 Gzip # cdn 引入 index.html 文件中引入 link/script 引入 (cdn 或 ukg 链接) build/webpack.base.conf.js 中添加 external 配置，webpack 打包时会跳过配置中的插件 去除 import…from… 和 use 什么的，不去除照样会打包，其他照常然后就 OK 了，我看到的文档大都是这样的，不是很清晰哈，那看代码 index.html (tips: 先后顺序、引入的地方) 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;title&gt;myapp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- cdn引入 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack 配置123456789101112131415module.exports = {context: path.resolve(__dirname, '../'),entry: { ...},externals: { // 要引入的资源的名字：该模块提供给外部引用的名字(由对应的库自定) 'vue': 'Vue', 'vue-router': 'VueRouter', 'element-ui': 'ELEMENTUI', 'echarts': 'echarts'},output: { ....19} main.js 中 (tips: 文件中 import router from ‘./router’ 并不是引入的 vueRouter 看路径) 123456789101112131415161718192021// import Vue from 'vue'import App from './App'// 这里不是引入的vueRouterimport router from './router'// import ElementUI from 'element-ui'// import 'element-ui/lib/theme-chalk/index.css'// import echarts from 'echarts'Vue.config.productionTip = false// Vue.use(ElementUI)// Vue.prototype.$echarts = echarts/* eslint-disable no-new */new Vue({ el: '#app', router, components: { App }, template: '&lt;App/&gt;'}) router/index.js 文件下 （tips: 脚手架中初始使用的为 router 这里要改为 VueRouter 原因看 external 那一步） 123456789101112131415// import Vue from 'vue'// import router from 'vue-router' // 这里才是引入的路由import HelloWorld from '@/components/HelloWorld'// Vue.use(VueRouter)export default new VueRouter({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld } ]}) 这样配置好之后，开发环境下，项目照常是可以运行的，打包后查看文件大小分布，嗯～真香。","link":"/blog/2018/02/03/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8Evendorjs%E4%B8%BB%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7/"},{"title":"webpack工程化","text":"# webpack 是什么 webpack 是一个现代 JavaScript 应用程序的静态模块打包器 (module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图 (dependency graph)， 其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle # 几个基本概念 entry 入口文件 output 输出 loader plugins # entry 入口文件，类似于其他语言的起始文件 指示 webpack 使用某个文件作为构建内部依赖图的开始，可以为多个 以 entry 属性配置 # output 告诉 webpack 构建好后 在哪里输出所创建的 bundle 及如何命名等 output: # loader 让 webpack 处理非 javascript 文件 (webpack 自身只理解 js) loader 可以将各个类型的文件转换为 webpack 可以处理的模块 如 css less vue jsx’ # plugins 打包优化和压缩，重新定义环境中的变量等更广的任务 # 基础 demo 理解打包模式 # 建立工程目录 123456789101112131415mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install webpack webpack-cli --save-dev# 目录结构# webpack-demo/src - index.js/dist - index.htmlpackage.jsonwebpack.config.js # 编写 /src/index.js 1234var dom = document.createElement('div)dom.innerHTML = 'hello webpack'document.body.appendChild(dom) # 编写 /dist/index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;xxx&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; # 编写 webpack.config.js 12345678module.exports = { mode: 'development', entry: './src/index.js', output: { path: __dirname + '/dist', filename: 'bundle.js' }} # 构建 12npx webpack# 查看dist下的index.html是否生效 # 配置 loader 加载 css # loader 原理 很多 loader 的职责都是单一的，只需要完成一种转换。 若一个源文件需要多步转换才能使用，就需要多个 loader 去转换，loader 会顺序执行 # 一个最简单的 loader 源码 12345678910111213141516171819202122232425262728293031323334353637383940// 运行在nodejs中const sass = require('node-sass')module.exports = function(source) { // source 为 compiler 传递给 Loader 的一个文件的原内容 // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换 // return source // or return sass(source)}// 使用// nodemodule中// module.exports = {// module: {// rules: [// {// test: /\\.sass$/',// use: ['sass-loader', 'node-sass'],// // include// }// ]// }// }// 自定义文件（vuecli中）// vue.config.jsmodule.exports = { configureWebpack: config =&gt; { config.module.rules.push({ test: /\\.txt$/, use: [ { // 文件在本地的地址 loader: path.resolve('./test-loader'), // options: {} } ] }) }} # bable-loader 转换 es6 12345678910111213141516171819module.exports = function(source) { // 通过 this.callback 告诉 Webpack 返回的结果 this.callback(null, source, sourceMaps); // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 return // 其中的 this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信 // this.callback( // // 当无法转换原内容时，给 Webpack 返回一个 Error // err: Error | null, // // 原内容转换后的内容 // content: string | Buffer, // // 用于把转换后的内容得出原内容的 Source Map，方便调试 // sourceMap?: SourceMap, // // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 // abstractSyntaxTree?: AST // )} # plugins 原理 # 编写 plugin 1234567891011121314151617181920class DemoPlugin { // 在构造函数中获取用户给该插件传入的配置 constructor(option) { } // Webpack 会调用 DemoPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply(compiler) { compiler.plugin('compilation', function(compilation) { }) }}modue.exports = DemoPlugin// 使用const DemoPlugin = require('./DemoPlugin.js')module.export = { plugins: [ new DemoPlugin(options) ]}","link":"/blog/2020/06/12/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"title":"前端知识点总结","text":"# js / 浏览器 # 1. JS 垃圾回收与 V8 垃圾回收机制 编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需的内存分配以及无用内存的回收完全是自动管理。 JavaScript V8 中自动垃圾回收机制的原理为： # v8 垃圾回收机制使用的是标记清除法 找出那些不再使用的变量，然后释放其占用的内存。 垃圾收集器会按照固定的时间间隔 (或预定的收集时间) 周期性 地执行此操作。 # 引用计数法 含义为跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数为 1，如果同一个值又被赋给另一个变量，该值的引用次数加 1，如果包含这个值引用的变量又取得了另外一个值，则这个值得引用次数减 1. 当引用次数为 0 时回收其占用得内存空间。 # 2. 描述 js 的事件循环机制 任务进入执行栈之后会判断一下是否是同步任务，若是同步任务就会进入主线程执行；异步任务就会到事件表里面注册回调函数到事件队列。 同步和异步任务分别进入不同的执行” 场所”，同步的进入主线程，异步的进入 Event Table 并注册函数 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的 Event Loop (事件循环) 宏任务：整体代码 script、setTimeout、setInterval、setImmediate, I/O, UI rendering。 微任务：原生 Promise 中 then 方法、process.nextTick、MutationObserver, Object.observe 事件循环机制 # 3. 什么是闭包，为什么有闭包概念，存在什么问题，适用什么应用场景 闭包就是能够读取其他函数内部变量的函数。使用不当造成内存泄露 函数嵌套函数 函数内部可以引用函数外部的参数和变量 参数和变量不会被垃圾回收机制回收 # 4. 讲一下原型链 每个对象都存在一个__proto__属性指向其构造函数的 prototype 属性值 12var a = {}a.__proto__ === Object.prototype // true # 5. 浏览器渲染 reflow（回流）：当浏览器发现某个部分发生了变化影响了布局，这个时候就需要倒回去重新渲染，这个过程就叫做 reflow； repaint（重绘）：当改变某个元素的背景色、字体颜色、边框颜色等不影响布局的属性时，屏幕的一部分需要重画，但是元素的几何尺寸和位置都没有发现变化； 浏览器将获取的 HTML 文档解析成 DOM 树； 处理 CSS 标记，构成层叠样式表模型（CSSOM）； 将 DOM 和 CSSOM 合并为渲染树（rendering tree）； 渲染树的每个元素的内容都是计算过的，称之为 布局 layout； 将渲染树上的各个节点绘制到屏幕上，称之为 绘制 painting； 浏览器渲染过程简析 # 6. 手动实现浅拷贝、深拷贝 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但对象的引用类型因为还是共享同一块内存，会相互影响。 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，前后的值互不影响。 1234567891011121314151617181920212223242526272829303132333435// 浅拷贝function clone(target) { let cloneTarget = {} for (const key in target) { cloneTarget[key] = target[key] } return cloneTarget}// 只考虑{}和基本类型function deepClone(target) { if (typeof target === 'object') { let cloneTarget = {} for (const key in target) { cloneTarget[key] = deepClone(target[key]) } return cloneTarget } else { return target }}// 复杂深拷贝function deepClone2(target, hash = new WeakMap()) { if (target === null) return target; if (target instanceof Date) return new Date(target); if (target instanceof RegExp) return new RegExp(target); if (typeof target !== 'object') return target; // 对象 let cloneObj = new target.constructor(); for (let key in target) { if (target.hasOwnProperty(key)) { cloneObj[key] = deepClone2(target[key]) } } return cloneObj;} # 7. 手动实现防抖节流函数 12345678910111213141516171819202122232425262728293031323334353637383940// 防抖// keyup事件、resize scrollfunction debounce(fn, delay, scope) { let timer = null; // 返回函数对debounce作用域形成闭包 return function () { // setTimeout()中用到函数环境总是window,故需要当前环境的副本； let context = scope || this, args = arguments; // 如果事件被触发，清除timer并重新开始计时 clearTimeout(timer); timer = setTimeout(function () { fn.apply(context, args); }, delay); }}// 节流function throttle(fn, threshold, scope) { let timer; let prev = Date.now(); return function () { let context = scope || this, args = arguments; let now = Date.now(); if (now - prev &gt; threshold) { prev = now; fn.apply(context, args); } }}function throttle2(fn, threshold, scope) { let timer; return function () { let context = scope || this, args = arguments; if (!timer) { timer = setTimeout(function () { fn.apply(context, args); timer = null; }, threshold) } }} # 8. new 操作符过程发生了什么 创建一个空对象 设置原型链。把构造函数的 prototype 属性 作为空对象的原型 (同时也有了 prototype 的方法，例如 this.age 就是用到了 prototype 的 this 这个方法) 改变 this 指向。this 赋值给这个空对象，执行构造函数函数，完成赋值 如果函数没有返回值 就返回这个 this 对象 # 9. 为什么会有跨域、怎么解决 浏览器的同源策略 服务端设置允许跨域 nginx 配置代理 jsonp 请求 # 10. 图片压缩原理 canvas drawImage # 11. 函数参数为外部的一个对象，函数内部删除对象的某个属性，元数据会不会改变 会，引用类型 123456789const data = { a: 1}function func (data) { data.a = 2 // delete data.a console.log(data, 'in') // { a: 2 }}func(data)console.log(data, 'out') // { a: 2 } # 12. 继承（手写 class 继承） 123456789101112131415161718class Person { constructor(name, age) { this.name = name this.age = age } sayHello(name) { console.log(`hello ${name}`) }}class men extends Person { constuctor(name, age) { super(name, age) }}const xiaohong = new Person('小红', 18)xiaohong.sayHello() // hello 小红const xiaogang = new men('小刚', 20)xiaogang.sayHello() # 13. bind、apply、call 的区别与作用 apply 接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以数组的形式传入，且当第一个参数为 null、undefined 的时候，默认指向 window (在浏览器中)，使用 apply 方法改变 this 指向后原函数会立即执行，且此方法只是临时改变 thi 指向一次。 call 方法的第一个参数也是 this 的指向，后面传入的是一个参数列表（注意和 apply 传参的区别）。当一个参数为 null 或 undefined 的时候，表示指向 window（在浏览器中），和 apply 一样，call 也只是临时改变一次 this 指向，并立即执行。 bind 方法和 call 很相似，第一参数也是 this 的指向，后面传入的也是一个参数列表 (但是这个参数列表可以分多次传入，call 则必须一次性传入所有参数)，但是它改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数。 # 14. Promise 简述与原理 # 15. 手动实现 map 函数 123456789101112Array.prototype.map2 = function (callback) { // map 要返回的结果 const result = [] for (let i = 0; i &lt; this.length; i++) { // 执行callback 函数 并传入数组的值 result.push(callback(this[i], i, this)) } return result}const arr = [1, 2, 3]const arr2 = arr.map2((item) =&gt; item * 2)console.log(arr2) // [2, 4, 6] # vue # 1. Vue 双向绑定 Object.defineProperty 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;box&quot;&gt; &lt;new-input v-bind:name.sync=&quot;name&quot;&gt;&lt;/new-input&gt; {{name}} &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;new-input&quot;, { props: [&quot;name&quot;], data: function () { return { newName: this.name, }; }, template: `&lt;label&gt;&lt;input type=&quot;text&quot; @keyup=&quot;changeName&quot; v-model=&quot;newName&quot; /&gt; 你的名字：&lt;/label&gt;`, methods: { changeName: function () { this.$emit(&quot;update:name&quot;, this.newName); }, }, watch: { name: function (v) { this.newName = v; }, }, }); new Vue({ el: &quot;#box&quot;, data: { name: &quot;nick&quot;, }, }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;input type=&quot;text&quot; v-mode=&quot;msg&quot; /&gt; &lt;p v-mode=&quot;msg&quot;&gt;&lt;/p&gt; &lt;script&gt; const data = { msg: &quot;你好&quot;, }; const input = document.querySelector(&quot;input&quot;); const p = document.querySelector(&quot;p&quot;); input.value = data.msg; p.innerHTML = data.msg; // 视图变数据跟着变 input.addEventListener(&quot;input&quot;, function () { data.msg = input.value; }); // 数据变视图变 let temp = data.msg; Object.defineProperty(data, &quot;msg&quot;, { get() { return temp; }, set(value) { temp = value; // 视图修改 input.value = temp; p.innerHTML = temp; }, }); data.msg = &quot;小李&quot;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; # 2. router 原理 https://juejin.cn/post/6844903615283363848 https://juejin.cn/post/6844903600913645582 1history.reaplceState history.pushState # 3. nextTick 原理，除了 Mutation Observer 还有什么实现方式 # 4. keepalive 如何实现刷新 # 5. computed 实现原理 # 6. created 和 mounted 的区别 # react # 1. react 的 setState 是同步异步？为什么 # 2. react 里性能优化在哪个生命周期函数？ shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 # 3. react 生命周期，各生命周期作用 componentWillMount () – 在渲染之前执行，在客户端和服务器端都会执行。 componentDidMount () – 仅在第一次渲染后在客户端执行。 componentWillReceiveProps () – 当从父类接收到 props 并且在调用另一个渲染器之前调用。 shouldComponentUpdate () – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回 true 否则返回 false。默认情况下，它返回 false。 componentWillUpdate () – 在 DOM 中进行渲染之前调用。 componentDidUpdate () – 在渲染发生后立即调用。 componentWillUnmount () – 从 DOM 卸载组件后调用。用于清理内存空间。 16.8+ 挂载阶段： constructor (props): 实例化。static getDerivedStateFromProps 从 props 中获取 state。 render 渲染。 componentDidMount: 完成挂载。 更新阶段： static getDerivedStateFromProps 从 props 中获取 state。 shouldComponentUpdate 判断是否需要重绘。 render 渲染。 getSnapshotBeforeUpdate 获取快照。 componentDidUpdate 渲染完成后回调。 卸载阶段： componentWillUnmount 即将卸载。 错误处理： static getDerivedStateFromError 从错误中获取 state。 componentDidCatch 捕获错误并进行处理。 # 4. 什么是高阶组件（hoc） 高阶组件 [higher order component] 是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 # 什么是 react fiber # hooks 原理 # 5. 简述 redux # 6. diff 算法实现 # 7. fiber 原理与实现 123456789101112131415161718192021222324// 三个原则// 单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。// 状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。// 使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。// redux的组件// Action – 这是一个用来描述发生了什么事情的对象。// Reducer – 这是一个确定状态将如何变化的地方。// Store – 整个程序的状态/对象树保存在Store中。// View – 只显示 Store 提供的数据。// 定义action// React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：function addTodo(text) { return { type: ADD_TODO, text }}// 简述// redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，// 工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，// flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰// 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们 # 6. react 类组件和函数组件区别与使用场景 # webpack # 1. 生产环境，webpack 如何加快编译速度 # 2. webpack 的几大概念？都是做什么的 entry output loader plugin # 3. loader 和 plugins 的区别和基本原理 # 网络 # tcp 第一次握手：客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认； 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK (ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过 “四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开） # http、https、http2 # 在地址栏里输入一个地址回车会发生哪些事情 https://juejin.cn/post/6844903919395536910 https://segmentfault.com/a/1190000006879700 解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 DNS 解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 TCP 三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 HTTPS 握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 TCP 四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。 # 算法 # 排序 快速排序 插入排序 冒泡排序 选择排序 归并排序 # 快速排序 快速排序的基本思想就是分治法的思想，寻找中间点，并对其左右的序列递归进行排序，直到左右都排序完成。 1234567891011121314151617function quickSort (arr) { if (arr.length == 0) { return arr } var pirotIndex = Math.floor(arr.length/2) var pirot = arr.splice(pirotIndex,1)[0] var left = [], right = [] for (var i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; pirot) { right.push(arr[i]) } else { left.push(arr[i]) } } return quickSort(left).concat(pirot, quickSort(right))}console.log(quickSort([2,4,6,1,7,8,4,9,99,6])) # 插入排序 将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序 # 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 123456789101112131415function bubbleSort(arr){ if(arr.length==0){ return arr } for(var i=0;i&lt;arr.length;i++){ for(j=0;j&lt;arr.length-1;j++){ if(arr[j]&gt;arr[j+1]){ // 交换位置 [arr[j],arr[j+1]]=[arr[j+1],arr[j]] //ES6解构 } } } return arr}console.log(bubbleSort([2,4,6,1,7,8,4,9,99,6])) # 二叉树 # diff 算法 # 其他 # 什么是进程、什么是线程 # 设计原则与设计模式 工厂模式 故名思意，我们从字面上的意思就可以看到，可以想象一座工厂源源不断产出一样的产品，流水线作业。没错，工厂模式就是这样。 单例模式 单例模式就是保证一个类仅有一个实例，并提供一个访问它的全局访问点。其实这有一点像我们 vuex 当中的实现，也是一个全局的状态管理，并且提供一个接口访问。 代理模式 我们在事件代理的时候其实就是使用了代理模式，通过把监听事件全部交由父节点进行监听，这样你添加节点或者删除节点的时候就不用去改变监听的代码。 发布订阅模式 这种模式在生活中随处可见，比如你订阅了一个网课，开始前 10 分钟就会提醒你去听课。这里其实就是发布 - 订阅的模式，你订阅了它的开课信息，但是你不会接收到另一门的开课信息，因为你没有订阅。 适配器模式 策略模式 迭代器模式","link":"/blog/2020/06/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"观察者模式和发布订阅模式","text":"# 观察者模式 当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。 以游戏为例：任务大厅和玩家 任务大厅推出任务订阅功能，玩家通过购买获得订阅权限；大厅发布任务后，通知拥有订阅权限的玩家 # 主体 任务大厅 1. 维护有订阅权限的玩家列表 2. 提供任务订阅功能 3. 发布任务后通知有订阅权限的玩家 接受任务通知的玩家们 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 观察者模式中：目标对象subject（任务大厅） 和 观察者observer（玩家们）// 任务大厅 --- 被观察者 class Subject { constructor() { // 维护有订阅权限的玩家列表 --- 观察者列表 this.observerList = [] } add(ob) { // 给玩家提供能拥有订阅权限的功能 --- 定义添加观察者的方法 this.observerList.push(ob) } notify(task) { // 推出新任务时，通知每个有订阅权限的玩家 --- 当自身变化后，通过调用自己的notify方法通知每个观察者执行update方法 console.log('notify:我推出任务了') this.observerList.forEach(ob =&gt; ob.update(task)) } } // 玩家 --- 观察者 class Observer { constructor(name) { this.name = name } update(task) { // 收到任务发布通知，自己做操作 // or 拒绝 or 接受任务 console.log('收到任务发布通知， 等待自己操作') if (task.type === 'war') { this.receiveTask() } else { this.refuseTask() } } refuseTask() {} receiveTask() {} } // 任务大厅 const subject = new Subject() // 玩家 const player1 = new Observer('玩家1') const player2 = new Observer('玩家2') // 玩家订阅 推出新任务的权限 subject.add(player1) subject.add(player2) // 发布任务1 const task1 = { type: 'war', info: '对战得装备' } subject.notify(task1) const task2 = { type: 'online', info: '在线得金币' } subject.notify(task2) # 发布订阅模式 基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。 以观看电视剧为例：电视剧制作方就是发布者 Publisher，观众就是订阅者 Subscribe，而类似优酷的平台则承担了事件通道 Event Channel 功能。 123456789101112131415161718192021222324252627282930313233343536373839// 发布-订阅模式 class PubSub { constructor () { // 每种事件下存放订阅者的回调 this.events = {} } subscribe(type, cb) { if (!this.events[type]) { this.events[type] = [] // this.events.war = [] } this.events[type].push(cb) // this.events.war = [cb] } publish(type, ...args) { if (this.events[type]) { this.events[type].forEach((cb) =&gt; cb(...args)) } } unSubscribe(type, cb) { if (this.events[type]) { // this.events // ... } } } const ps = new PubSub() // 订阅对战任务 ps.subscribe('war', (info) =&gt; { console.log(info, '订阅回调得到任务信息') if (info.type === 'war') { console.log('接受任务') } }) // 发布了对战任务, 因为已订阅，收到通知 ps.publish('war', task1) // 发布在线任务，没有订阅，无通知 ps.publish('online', task1)","link":"/blog/2022/09/08/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"title":"队列数据结构","text":"栈数据结构是遵循先进先出原则的一组有序的项。最新添加的元素必须排在队列的末尾，例：排队 123456789101112131415161718192021222324252627/* * enqueue: 向队列尾部添加一个或多个item --- push * dequeue: 移出队列的第一(队列最前面的)item，并返回被移除的元素 * front: 返回队列中的第一个元素(会最先被添加，也会最先被移除),队列不变动 * [不移除元素,只返回元素信息] */// 创建一个队列function Queue() { let items = [] // 属性和方法 console.log('同步执行') enqueue: function(ele) { items.push(ele) } dequeue: function() { return items.shift() } front: function() { return items[0] } print: function() { console.log(items.toString()) }}","link":"/blog/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%85%A1/"},{"title":"算法笔记-排序","text":"排序 12345678910111213141516171819202122231. sort 方法let arr = [3, 5, 21, 15，39]arr.sort((a, b) =&gt; a - b)console.log(arr) // [ 3, 5, 15, 21 ]2. 快速排序function quickSort(arr) { const len = arr.length if (len &lt; 1) return arr let leftArr = [], rightArr = [] const midIndex = Math.floor(len / 2) const midNum = arr.splice(midIndex, 1)[0] for (let i = 0; i &lt; len - 1; i++) { if (arr[i] &lt; midNum) { leftArr.push(arr[i]) } else { rightArr.push(arr[i]) } } return quickSort(leftArr).concat([midNum], quickSort(rightArr))} 12345678910111213141516171819202122232425262728293031323334353637383940处理方法splice、sort、concant、push、unshift、 pop、shift// splice(1,3) // 删除索引1后面的三个// splice(1,0,4) // 删除索引1后面的0个，再在后面添加一个4// sort() // 数字中两位的数字只按照第一个排序// sort((a, b) =&gt; return a - b) //1- 冒泡排序算法/* * 排序思想： * 让数组中的当前项和后一项进行比较，如果当前项比后一项大，则两项 * 交换位置（让大的靠后）即可 * 两两比较 * * 每次循环会把最大的放到最后面 * 最多比较length-1次 不用和自己比较 * 即：第二次循环里由于最后一个已经是最大的，所以没有必要再去比较，第二个循环里的循环长度就是length-1，为0时即比较完毕 * * * 空间复杂度O(1) * 平均时间复杂度O(n*n) */let ary = [12, 8, 24, 16, 1]function bubbleSort(ary) { // i控制比较的轮数 for (let i = 0; i &lt; ary.length - 1; i++) { // j控制每一轮比较的次数 for (let j = 0; j &lt; ary.length - i - 1; j++) { // 当前项大于后一项，放后面 if (ary[j] &gt; ary[j + 1]) { let temp = ary[j] ary[j] = ary[j + 1] ary[j + 1] = temp } } } return ary}bubbleSort(ary) // [ 1, 8, 12, 16, 24 ] 1234567891011121314151617181920212223242526272829302- 插入排序算法/* * 思想：找第一个a为基准循环跟其他数值比较，比a大的放后面 * */let arr = [12, 8, 24, 16, 1]function insertSort(arr) { result.push(arr[0]) for (let i = 0; i &lt; arr.length; i++) { let a = arr[i] for(let j = result.length - 1; j &gt;= 0; j-- ) { let b = result[j] if (a &gt; b) { result.splice(j + 1, 0, a) break } if (j === 0) { result.unshift(a) } } } return result}insertSort(arr) 出现次数最多 12输入: [1, 13, 43, 42, 13, 1, 3, 4, 4, 23, 13]输出: [1, 13, 43, 42, 3, 4, 23] 1234567891011function unique(arr) { let hashTable = {} let data = [] for (let i = 0; len = arr.length; i &lt; len; i++) { if (!hashTable[arr[i]]) { hashTable[arr[i]] = true data.push(arr[i]) } } return data}","link":"/blog/2020/03/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"项目工具随手记","text":"# eggjs 中使用 mock 在项目中新建 mock 文件夹，里面专门存放各个 mock 数据 json 文件 123456789101112131415161718192021const glob = require('glob');const path = require('path');const mockRoutes = [];const mockFiles = glob.sync(path.join(__dirname, '../mock/**/*.json')); // 读取mock文件夹下的所有文件路径mockFiles.forEach((file) =&gt; { let route = file.split('/mock')[1].replace('.json', ''); // 获取真实api路径 if (route.includes('_/')) { route = `${route.split('_/')[0]}*`; } mockRoutes.push(route);});module.exports = (app) =&gt; { const { router, controller } = app; mockRoutes.forEach((path) =&gt; { router.all(path, controller.proxy.proxyToMock); });}; # 获取路径中的参数 12345678910111213function getQuery(k) { let searchStr = window &amp;&amp; window.location.search &amp;&amp; location.search.slice(1); if (searchStr) { const searchArr = searchStr.split('&amp;') || []; const result = searchArr.reduce((obj, item) =&gt; { let [key, ...value] = item.split('='); let ans = decodeURIComponent(value.join('')); obj[key] = ans; return obj; }, {}); return k ? result[k] : result; }} # 生成指定范围的随机整数 12345// @param {Number} start 区间起点 // @param {Number} end 区间终点function rand(start, end) { return Math.round(Math.random() * (end - start) + start);} # 防抖 123456789101112131415/** * @param {Function} fn 函数 * @param {Number} delay 时延 * @param {Object} context 上下文 * @return {Function} */export function debounce(fn, delay = 100, context = null) { let timer = null; return (...params) =&gt; { clearTimeout(timer); timer = setTimeout(() =&gt; { fn.call(context, ...params); }, delay); };} # 节流 1234567891011121314151617181920212223/** * @param {Function} fn 函数 * @param {Number} threshold 时延 * @param {Object} context 上下文 * @return {Function} */function throttle(fn, threshold = 50, context = null) { let last; let timer = null; return (...params) =&gt; { const now = +new Date(); if (last &amp;&amp; now &lt; last + threshold) { clearTimeout(timer); timer = setTimeout(() =&gt; { last = now; fn.call(context, ...params); }, threshold); } else { last = now; fn.call(context, ...params); } };} # 复制 1234567891011121314151617181920212223242526import ***function copyText(text) { return new Promise(function (resolve, reject) { var fakeElement = document.createElement('button'); var clipboard = new Clipboard(fakeElement, { text: function () { return text; }, action: function () { return 'copy'; }, container: document.body }); clipboard.on('success', function (e) { clipboard.destroy(); resolve(e); }); clipboard.on('error', function (e) { clipboard.destroy(); reject(e); }); document.body.appendChild(fakeElement); fakeElement.click(); document.body.removeChild(fakeElement); });} # 获取字符的长度（包括中英文符号等） 123456789101112const getStringWidth = (val) =&gt; { let len = 0 for (let i = 0; i &lt; val.length; i++) { const length = val.charCodeAt(i) if (length &gt;= 0 &amp;&amp; length &lt;= 128) { len += 1 } else { len += 2 } } return len } # 等待执行 1export const sleep = (delay) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(null), delay)); # 是否为闰年 123export function isLeapYear(y) { return y % 100 ? !(y % 4) : !(y % 400);} # 获取路径中所有的 query 123456789101112131415161718export const getUrlParam = () =&gt; { try { // 获取url中&quot;?&quot;符后的字串 const url = location.search; const theRequest: any = {}; if (url.indexOf('?') !== -1) { const str = url.substr(1); const strs = str.split('&amp;'); for (let i = 0; i &lt; strs.length; i++) { const [k = '', v = ''] = strs[i].split('='); theRequest[k] = decodeURIComponent(v); } } return theRequest; } catch (e) { return {}; }}; # 将 object 拼接成 query 格式的 string 123456789101112131415/** * 将object拼接成query格式的string * @param object * @returns string param1=xxx&amp;param2=xxx */export const setUrlSearch = (objs = {}) =&gt; { const _rt: any = []; Object.keys(objs).forEach((key) =&gt; { const _val = objs[key]; if (_val) { _rt.push(`${key}=${typeof _val === 'object' ? JSON.stringify(_val) : _val}`); } }); return _rt.join('&amp;');};","link":"/blog/2020/11/08/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[{"name":"vue","slug":"vue","link":"/blog/tags/vue/"},{"name":"nodejs","slug":"nodejs","link":"/blog/tags/nodejs/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","link":"/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"server","slug":"server","link":"/blog/tags/server/"},{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"nodejs","slug":"nodejs","link":"/blog/categories/nodejs/"}],"pages":[{"title":"","text":"# about me","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"link","text":"","link":"/blog/link/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}]}