{"posts":[{"title":"EventLoop","text":"javascript 事件循环机制 1234567891011121314151617// javascript 事件循环机制分为浏览器和node事件循环机制// 浏览器Event Loop是HTML中定义的规范// Node Event Loop 是由libuv 库实现。JavaScript有一个main thread 主线程和call-stack调用栈（执行栈），所有的任务都会放到调用栈中等待主线程执行。1. JS 调用栈 是一种先进后出的数据结构。当函数被调用时，会被添加到栈中的顶部。 执行完成之后就从栈顶部移出该函数，直到栈内被清空。2. 同步任务、异步任务 JavaScript单线程中的任务分为同步任务和异步任务。 同步任务会在调用栈中按照顺寻排队等待主线程执行。 异步任务则会在异步有了结果之后将注册的回调函数添加到任务队列（消息队列）中等待主线程空闲的时候， 也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。3. Event Loop 调用栈中的同步任务都型执行完毕，栈内被清空了，就代表主线程空闲了， 这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。 每次栈内被清空，都会去读取任务队列，有就读取执行，一直循环-执行操作，就形成了事件循环。","link":"/blog/2019/09/10/EventLoop/"},{"title":"Vue原理一","text":"# vue 源码目录 123456789101112131415161718192021222324├── build --------------------------------- 构建相关的文件├── dist ---------------------------------- 构建后文件的输出目录├── examples ------------------------------ 存放使用Vue开发的的例子├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)├── package.json -------------------------- 项目依赖├── test ---------------------------------- 包含所有测试文件├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码│ ├──platforms --------------------------- 包含平台相关的代码│ │ ├──web ----------------------------- 包含了不同构建的包的入口文件│ │ | ├──entry-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意│ │ | ├── entry-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器│ ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数│ │ ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码│ │ ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码│ │ ├── optimizer.js ------------------ 分析静态树，优化vdom渲染│ ├── core ------------------------------ 存放通用的，平台无关的代码│ │ ├── observer ---------------------- 反应系统，包含数据观测的核心代码│ │ ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码│ │ ├── instance ---------------------- 包含Vue构造函数设计相关的代码│ │ ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── components -------------------- 包含抽象出来的通用组件│ ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码│ ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包│ ├── shared ---------------------------- 包含整个代码库通用的代码 # Vue 构造函数 目录 /src/instance/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}// 在vue的原型prototype上挂载方法或属性 都在/src/core/instance目录下initMixin(Vue)stateMixin(Vue)eventMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue// initMixinVue.prototype._init = function (options) {}// stateMixinVue.prototype.$dataVue.prototype.$propsVue.prototype.$setVue.prototype.$delete = delVue.prototype.$watch = function () {}// eventsMxinVue.prototype.$onVue.prototype.$onceVue.prototype.$offVue.prototype.$emit// lifecycleMixinVue.prototype._updateVue.prototype.$forceUpdateVue.prototype.$destory// renderMixinVue.prototype.$nextTick Vue.prototype._render Vue.prototype._o = markOnce Vue.prototype._n = toNumber Vue.prototype._s = toString Vue.prototype._l = renderList Vue.prototype._t = renderSlotVue.prototype._q = looseEqual Vue.prototype._i = looseIndexOf Vue.prototype._m = renderStatic Vue.prototype._f = resolveFilter Vue.prototype._k = checkKeyCodes Vue.prototype._b = bindObjectProps Vue.prototype._v = createTextVNode Vue.prototype._e = createEmptyVNode Vue.prototype._u = resolveScopedSlots Vue.prototype._g = bindObjectListeners # 初始化实列 根据 Vue 的生命周期，Vue 首先会进行 init 初始化操作； 源码在 src/core/instance/init.js 中 123456789101112131415161718/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, 'created') # 引入依赖，挂载静态方法和属性 123456789101112131415161718192021222324252627// [/src/core/index.js](https://github.com/vuejs/vue/blob/dev/src/core/index.js)import Vue from './instance/index'import { initGlobalAPI } from './global-api/index'import { isServerRendering } from 'core/util/env'// import { FunctionalRenderContext } from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', { get: isServerRendering})Object.defineProperty(Vue.prototype, '$ssrContext', { get () { /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext }})// expose FunctionalRenderContext for ssr runtime helper installation// Object.defineProperty(Vue, 'FunctionalRenderContext', {// value: FunctionalRenderContext// })Vue.version = '__VERSION__'export default Vue # 进入 global-api 1234567891011121314151617181920Vue.set = setVue.delete = delVue.nextTick = nextTick// ASSET_TYPES: ['component', 'directive', 'filter']// ASSET_TYPES.forEach(type =&gt; {// Vue.options[type + 's'] = Object.create(null)// })Vue.options = { components: { KeepAlive }, directives: {}, filters: {}, _base: Vue}Vue.use Vue.mixin Vue.cid = 0 Vue.extend Vue.component = function(){} Vue.directive = function(){} Vue.filter = function(){} # Object.defineProperty 响应式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // ... Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} # VNode 概念 1234567891011121314151617181920212223242526272829export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching fnScopeId: ?string; // ...}","link":"/blog/2020/04/20/Vue%E5%8E%9F%E7%90%86%E4%B8%80/"},{"title":"vue-axios","text":"# Vue 中封装 axios 的一种方法 安装 axios 1npm install axios --save 单独写个文件配置 axios, 此处命名为 request.js 1234567891011121314151617181920212223242526272829import axios from axios//自定义配置新建一个axios实例const http = axios.create({ // baseURL: 'https://...' // baseURL: process.env.BASE_API, timeout: 5000, // 请求延迟 // headers: {'x-Request-with': '*'} //自定义请求头 // ....})// 添加请求拦截器http.interceptors.request.use(config =&gt; { // 请求前设置请求头 config.headers['Access-Control-Allow-Origin'] = '*' // config.headers['Authorization'] = getToken() // config.headers['Actcode'] = getCode() return config}, error =&gt; { console.log(error, '888') //请求错误 dsth return Promise.reject(error)})// 响应拦截器http.interceptors.response.use(response =&gt; { return response}, error =&gt; { console.log(error, '888')//返回消息后 dsth return Promise.reject(error)})export default http // 记住此处 api.js 文件中配置请求 12345678910import http from '@/http/request'export function requestDemo (showapi_appid, showapi_sign) { //方法名 requestDemo const pass = {showapi_appid, showapi_sign} return http({ url: 'http://route.showapi.com/60-27', method: 'post', data: pass })} 页面中使用 1234567import { requestDemo } from '@/../api'const params = { name: 'laine', pw: '123456'}requestDemo(params).then().catch()","link":"/blog/2019/07/20/axios%E5%B0%81%E8%A3%85/"},{"title":"栈数据结构","text":"# 栈是一种遵从先进后出原则的有序结合。 新添加的或待删除的元素都保存在栈的同一端，为栈顶，另一端则为栈底。且新元素都靠近栈顶，旧元素都接近栈底。 例：一摞书、堆起的盘子 # 创建一个类来表示栈： 123function Stack { // 属性和方法} # 选择一种数据结构保存栈里的元素（这里选择数组）： 1let items = [] 声明一些需要用到的一些方法 push pop peek isEmpty clear size 向栈中添加元素（只向栈中的末尾即栈顶添加） 123this.push = function(ele) { items.push(ele)} 移出栈中的元素（移出末尾即栈顶） 123this.pop = function() { return items.pop()} 查看栈顶元素、检查栈是否为空、清空栈、打印栈元素 123456789101112131415this.peek = function() { return items[items.length - 1]}this.isEmpty = function() { return item.length === 0}this.clear = function() { items = []}this.print = function() { console.log(items.toString())} # 使用 Stack 类 1234567let stack = new Stack() // []console.log(stack.isEmpty()) // truestack.push(2) // [2]stack.peek() // 2 # es6 改造此类 123456789class Stack { constructor() { this.items = [] } push(ele) { this.items.push(ele) } ...} es6 创建的类基于原型，比基于函数的节省内存，更适合创建多个实例。但是不能声明私有属性，此处的 items 是公共的。 # 再改造（利用 es6 的限定作用域 Symbol 实现） es6 新增的 Symbol 的基本类型，不可变，可以用作对象的属性 1234567891011let _items = Symbol()class Stack() { constructor() { this[_items] = [] } push(ele) { this[_items].push(ele) } ...} 缺点: _items 属性是个数组，可以进行任意的数组操作，例如从中间删除和添加。栈中不该有这种行为 # 再次改造（WeakMap 数据类型）（可确保属性是私有的） 12345678910111213141516171819202122232425262728const items = new WeakMap()class Stack { constructor() { items.set(this, []) } push(ele) { let s = items.get(this) s.push(ele) } pop() { let s = items.get(this) let r = s.pop() return r } ...}// 利用闭包把stack类包起来let stack = (function() { const items = new WeakMap() class Stack { constructor() { items.set(this, []) } } ... // 其他方法 return Stack})()","link":"/blog/2020/03/25/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%85%A0/"},{"title":"nodejs实战笔记-常用功能","text":"# 创建静态文件服务器 # 所需模块 123456var http = require('http')var fs = require('fs')var path = require('path')var mime = require('mime') // 附加的mime模块 有根据文件扩展名得出mime类型的能力var cache = {} # 工具函数 1234567891011121314// 错误数据function send404(response) { response.writeHead(404, { 'Content-Type': 'text/plain' }) response.write('Error 404: resource not found') response.end()}// 文件数据function sendFile(response, filePath, fileContents) { response.writeHead( 200, { 'Content-Type': mime.lookup(path.basename(filePath)) } ) response.end(fileContents)} # 提供静态服务 访问内存 (ram) 要比访问文件系统快很多，node 程序中通常会把常用的数据缓存到内存里。 只有第一次访问的时候需要从文件系统中读取 123456789101112131415161718192021function serveStatic(response, cache, absPath) { if (cache[absPath]) { sendFile(response, absPath, cache[absPath]) } else { fs.exists(absPath, function(isExist) { if (isExist) { fs.readFile(absPath, function(err, data) { if (err) { send404(response) } else { // 从硬盘中读取文件并返回 cache[absPath] = data sendFile(response, absPath, data) } }) } else { send404(response) } }) }} # 创建 http 服务器 1234567891011121314var server = http.createServer(function(request, response) { var filePath = false if (request.url == '/') { filePath = 'public/index.html' } else { // 将url路径转为文件的相对路径 filePath = 'public' + request.url } var absPath = './' + filePath serveStatic(response, cache, absPath)})server.listen(3000)","link":"/blog/2020/03/28/nodejs%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"title":"nodejs实战笔记-mysql的基本使用","text":"连接 12345678const mysql = require('mysql')const db = mysql.createConnection({ host: '127.0.0.1', user: 'root', password: 'root', database: 'myblog'}) 创建数据库表 12345678910111213db.query( `CREATE TABLE IF NOT EXISTS work ( id INT(10) NOT NULL AUTO_INCREMENT, hours DECIMAL(5,2) DEFAULT 0, date DATE, desc LOGGTEXT, PRIMARY KEY(id))`, function(err) { if (err) throw err console.log('server started') server.listen(3000, '127.0.0.1') }) 常用操作 123456789101112131415161718192021222324252627exports.add = (db, req, res) =&gt; { db.query( `ININSERT INTO work (hours, date, desc) VALUES (?,?,?) [hoursVal,dateval,descVal]` )}exports.delete = (db, req, res) =&gt; { db.query( ` DELETE FROM work WHERE id=? [idVal] ` )}exports.show = (db, req, curId) =&gt; { const query = ` SELECT * FROM work WHERE archived=? ORDER BY date DESC ` const curId = curId ? 1 : 0 db.query( query, [curId] )}","link":"/blog/2020/04/24/nodejs%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%8Bmysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"nodejs实现单线程高并发原理","text":"# 前言 在我接触 Nodejs 的时候，听的最多的关键字就是：事件驱动、非阻塞 I/O、高效、轻量，是单线程且支持高并发的脚本语言。可为什么单线程的 nodejs 可以支持高并发呢？很多人都不明白其原理，自己也在很长一段时间内被这些概念搞的是云里雾里。下面我们就来一步一步揭开其神秘的面纱。并且，通过底层 C/C++ 源码的学习，来剖析 Nodejs 实现高并发的之一 ------ 事件循环的实现。 # 从 Node.js 进入我们的视野时，我们所知道的它就由这些关键字组成 事件驱动、非阻塞 I/O、高效、轻量，它在官网中也是这么描述自己的。 于是在我们刚接触 Nodejs 时，会有所疑问： 为什么在浏览器中运行的 Javascript 能与操作系统进行如此底层的交互？ nodejs 真的是单线程吗？ 如果是单线程，他是如何处理高并发请求的？ nodejs 事件驱动是如何实现的？ # 架构一览 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。 Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。 Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。 Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。 C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。 # 与操作系统交互 举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码： 1234var fs = require('fs');fs.open('./test.txt', &quot;w&quot;, function(err, fd) { //..do something}); 这段代码的调用过程大致可描述为：lib/fs.js → src/node_file.cc → uv_fs 12345678910111213141516171819202122232425262728293031323334353637lib/fs.jsasync function open(path, flags, mode) {mode = modeNum(mode, 0o666);path = getPathFromURL(path);validatePath(path);validateUint32(mode, 'mode');return new FileHandle(await binding.openFileHandle(pathModule.toNamespacedPath(path),stringToFlags(flags),mode, kUsePromises));}src/node_file.ccstatic void Open(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {Environment* env = Environment::GetCurrent(args);const int argc = args.Length();if (req_wrap_async != nullptr) { // open(path, flags, mode, req)AsyncCall(env, req_wrap_async, args, &quot;open&quot;, UTF8, AfterInteger,uv_fs_open, *path, flags, mode);} else { // open(path, flags, mode, undefined, ctx)CHECK_EQ(argc, 5);FSReqWrapSync req_wrap_sync;FS_SYNC_TRACE_BEGIN(open);int result = SyncCall(env, args[4], &amp;req_wrap_sync, &quot;open&quot;,uv_fs_open, *path, flags, mode);FS_SYNC_TRACE_END(open);args.GetReturnValue().Set(result);}}uv_fs/* Open the destination file. */dstfd = uv_fs_open(NULL,&amp;fs_req,req-&gt;new_path,dst_flags,statsbuf.st_mode,NULL);uv_fs_req_cleanup(&amp;fs_req); 具体来说，当我们调用 fs.open 时，Node.js 通过 process.binding 调用 C/C++ 层面的 Open 函数，然后通过它调用 Libuv 中的具体方法 uv_fs_open，最后执行的结果通过回调的方式传回，完成流程。我们在 Javascript 中调用的方法，最终都会通过 process.binding 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。 # 为什么一个单线程的效率可以这么高，同时处理数万级的并发而不会造成阻塞呢？就是我们下面所说的 -------- 事件驱动。 每个 Node.js 进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。 主线程之外，还维护了一个 &quot;事件队列&quot;（Event queue）。当用户的网络请求或者其它的异步操作到来时，node 都会把它放到 Event Queue 之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。 主线程代码执行完毕完成后，然后通过 Event Loop，也就是事件循环机制，开始到 Event Queue 的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交 EventLoop 处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。 主线程不断重复上面的第三步。 我们所看到的 node.js 单线程只是一个 js 主线程，本质上的异步操作还是由线程池完成的，node 将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的 I/O 操作，从而实现异步非阻塞 I/O，这便是 node 单线程和事件驱动的精髓之处了 原文链接","link":"/blog/2020/09/04/nodejs%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"},{"title":"nuxt2.x小结","text":"使用之前先撸遍官方文档 # 绝多部分问题，都可以在网上搜得到，所以整体开发还算顺利，难度一般，以下纪录本人项目中用到和总结的一些知识，后面有新的问题会更新，欢迎讨论！ # 路由守卫 使用nuxt的middleware功能，中间件允许一个函数在每个页面进入之前运行 可以在页面中使用/可以全局使用 12345678910111213141516// middleware/route.js// 接收context作为第一个参数export default ({ route, redirect, app, store }) =&gt; { if (!store.state.userInfo.userId) { return redirect('/login') } if (route.fullPath === '/mine') { return redirect('/mine/account') }}// nuxt.config.js中配置module.exports = { router: { middleware: 'route' }} # 自定义全局方法 用到nuxt中的plugins功能 nuxt在运行程序之前执行js插件（适用自己的库或第三方模块,修改plugin时需要重启项目） 此处封装localstorge操作 // 只允许mounted之中调用 123456789101112131415161718192021222324252627282930313233343536373839// /plugins/utils.jsimport Vue from 'vue'const storge = { install(Vue) { /** * @params key setItem key * @params value setItem value * @params expire 过期时间&lt;number&gt; 默认7 */ Vue.prototype.$setStorge = (key, value, expire = 7) =&gt; { let obj = { value, time: Date.now(), expire: expire * 60 * 60 *24 } localStorage &amp;&amp; localStorage.setItem(key, JSON.stringify(obj)) } Vue.prototype.$getStorge = (key) =&gt; { let val = localStorage.getItem(key) if (!val) return null val = JSON.parse(val) // 过期 if ((Date.now() - val.time) &gt; val.expire) { localStorage.removeItem(key) return null } return val.value } Vue.prototype.$delStorge = (key) =&gt; { localStorage.removeItem(key) } }}Vue.use(storge)// nuxt.config.js中需配置plugins字段，参考middleware # nuxt 中使用 vuex store目录中新建user.js 直接暴露state等属性 不使用模块化，直接新建index.js 暴露 123456789101112131415export const state = () =&gt; ({ userInfo: null})export const mutations = { setUserInfo(state, data) { state.userInfo = data }}export default { state, // getters, // actions, mutations} # 服务端获取数据 asyncData方法 页面级组件中服务端才会生效的钩子 页面刷新时不执行 return 出去的对象会放入到客户端中的 data 数据中 1nuxtServerInit 获取服务端数据 可访问到服务端的 context 对象 只存在于 vuex 中 12nuxt会在每一次请求服务器页面时执行，即：首次进入页面或刷新页面且只存在于vuex中的action对象中 1234567891011// vuex中记录获取cookie记录登录状态export const actions = { nuxtServerInit({ commit }, { req }) { try { let cookies = req.headers['cookie'] console.log(cookies) } catch (error) { console.log(error) } }} # 页面或全局引用 script 链接 12345678// 组件或nuxtconfigjsexport default { head: { script: [ { src: '***' } ] }} # 动态设置页面 title 及 meta 信息 12345678910export default { head() { return { title: '***'， meta: { hid: 'description', name: 'description', content: '***' } } }} # nuxt 部署 服务端安装工具 node、yarn、pm2 1234curl --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash -sudo yum install -y nodejssudo yum install yarnnpm install -g pm2 本地 nuxt 项目代码执行 npm run build（.nuxt 文件夹下会生成 dist 文件目录） 把.nuxt、static、nuxt.config.js、package.json server 五个文件夹拖到服务器上 服务器上安装依赖 npm install 启动项目 npm run start 启动进程守护 pm2 start npm --name “package.json 文件中得 name” – run start # 第一次部署时出错 12345678910- Unexpected identifier // 意外的识别码(function (exports, require, module, __filename, __dirname) { import Modal from './confirm' })// 很多说的是项目中缺少识别import引入方式的babel// 按照参考下载了也没用// 找不到解决方法, 后来发现，iview的按需引入处的错误// package.json中的iview版本为3.15也就是iview// 而按需引入中的包名使用'iview'就会报错// 改为'view-design'解决 123456&quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;view-design&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; }]] # nginx 部分配置 123location / { proxy_pass http://localhost:3000;} # 引入百度统计代码 新建 plugins/baidu.js 1234567891011export default ({app: {router}, store}) =&gt; { /* 每次路由变更时进行pv统计 */ router.afterEach((to, from) =&gt; { /* 告诉增加一个PV */ try { window._hmt = window._hmt || [] window._hmt.push(['_trackPageview', to.fullPath]) } catch (e) { } })} 123script: [ { src: 'https://hm.baidu.com/hm.js?****' }] nuxt.config.js 中配置 plugins 字段 # 开启 https nuxt.config.js 中的 server 字段 123456789101112const path = require('path')const fs = require('fs')module.exports = { server: { https: { // 此处路径可以直接写死 读取https证书文件 // key: fs.readFileSync(path.resolve(__dirname, '**server.key')) key: fs.readFileSync('/usr/local/***.key') } }}","link":"/blog/2020/01/22/nuxt2-x%E5%B0%8F%E7%BB%93/"},{"title":"nuxt部署","text":"服务器: centos7.6 版本 # 安装 nginx 不怎么懂各种操作的意思，网上有很多参考文章。https://www.cnblogs.com/bluestorm/p/4574688.html nginx 配置 1234567891011server { listen 8000; # listen somename:8080; server_name localhost; location /admin { // 访问ip:8080/admin 时会出现/var/www/admin下的indexhtml文件 # root html; alias /var/www/admin; index index.html index.htm; }} 安装 nodejs、yarn、pm2 12345678url --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash - // 下载源文件sudo yum install -y nodejs // 安装nodejs (node -v)sudo yum install yarn // 安装yarnnpm install -g pm2 本地 nuxt 项目代码执行 npm run build (.nuxt 文件夹下会生成 dist 文件目录) 把 .nuxt、static、nuxt.config.js 、package.json 四个文件夹复制到服务器上 服务器上 执行 npm install -production（生产环境安装依赖） npm run start （开启 node 服务）（若缺失什么文件会有提示，再复制过去即可） 此时正常情况下，网站已经可以访问。退出 xshell 后，就会报错（缺少 pm2 进程守护） pm2 start npm --name “package.json 文件中的 name” – run start # 问题 公司服务器上安装 nodejs 的时候 执行 curl 和 install 两步后 node -v 查看版本后 没有出现版本号 试了很多次，都没有成功，最后 到 /etc/yum.repos.d 下关于 nodesource… 的文件有两个，全部手动删除 重新执行 curl 和 install 那两步后 node -v npm -v 成功安装 # pm2 常用命令 1234567- pm2 list 查看所有启动的应用程序- pm2 show app-name 查看某app所有信息- pm2 delete all 删除所有- pm2 stop 0 停止指定id的应用 # 目前更新项目： 12345678npm run build 后 把那五个文件夹放到服务器上之后 需要重启node服务ps aux | grep node 查看node进程 sudo kill -9 &lt;进程号&gt;目录下启动服务 npm run start目录下开启进程守护 pm2 start npm --name &quot;package.json文件中的name&quot; -- run start","link":"/blog/2020/03/22/nuxt%E9%83%A8%E7%BD%B2/"},{"title":"serverless","text":"参考一 参考二 前端开发模式的技术表格即技术演进 serverless 常见服务商提供的解决方案 基于 serverless 的前端开发模式 # 前端开发模式的演进 基于 php/java 的模板渲染的动态页面 基于 ajax 的前后端分离模式 基于 nodejs 的前端工程化 基于 nodejs 的全栈开发 # 模板渲染 在早起的互联网时代，我们的网页很简单，就是一些静态或动态的页面，主要目的是用来做信息的展示和传播。这个时候开发一个网页也很 easy，主要就是通过 JSP、PHP 等技术写一些动态模板，然后通过 Web Server（nginx，apache） 将模板解析成一个个 HTML 文件，浏览器只负责渲染这些 HTML 文件。这个阶段还没有前后端的分工，通常是后端工程师顺便写了前端页面。 JSP: Java Server Page: Java 服务端页面，在 html 页面中编写 Java 代码的页面 WebServer：网站服务器或 web 服务器 # ajax 2005 年 AJAX 技术的正式提出，翻开了 Web 开发的新篇章。基于 AJAX，我们可以把 Web 分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理。前后端通过接口进行数据交互。我们也不再需要在各个后端语言里面写着难以维护的 HTML。网页的复杂度也由后端的 Web Server 转向了浏览器端的 JavaScript。也正因如此，开始有了前端这个职位 # nodejs 工程化 2009 年 Node.js 的出现，对于前端来说，也是一个历史性的时刻。随着 Node.js 一同出现的还有 CommonJS 规范和 npm 包管理机制。随后也出现了 Grunt、Gulp、Webpack 等一系列基于 Node.js 的前端开发构建工具。 在 2013 年前后，前端三大框架 React.js/Angular/Vue.js 相继发布第一个版本。我们可以从以往基于一个个页面的开发，变为基于一个个组件进行开发。开发完成后使用 webpack 等工具进行打包构建，并通过基于 Node.js 实现的命令行工具将构建结果发布上线。前端开发开始变得规范化、标准化、工程化。 # nodej 全栈开发 Node.js 对前端的重要意义还有，以往只能运行在浏览器中的 js 也可以运行在服务器上，前端可以用自己最熟悉的语言来写服务端的代码。于是前端开始使用 Node.js 做全栈开发，开始由前端向全栈的方向转变。这是前端主动突破自己的边界。 另一方面，前端在发展，后端也在发展。也差不多在 Node.js 诞生那个时代，后端普遍开始由巨石应用模式向微服务架构转变。这也就导致以往的前后端分工出现了分歧。随着微服务架构的兴起，后端的接口渐渐变得原子性，微服务的接口也不再直接面向页面，前端的调用变得复杂了。于是 BFF（Backend For Frontend）架构出现了，在微服务和前端中间，加了一个 BFF 层，由 BFF 对接口进行聚合、裁剪后，再输出给前端。而 BFF 这层不是后端本质工作，且和前端的关系最大，所以前端自然而然选择了 Node.js 来实现。这也是当前 Node.js 在服务端较为广泛的应用的原因。 巨石应用 大部分 web 工程是将所有的功能模块 (service side) 打包到一起并放在一个 web 容器中运行，很多企业的 Java 应用程序打包为 war 包 微服务架构 微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。 # serverless CNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年 7 月 21 日（于美国波特兰 OSCON 2015 上宣布），其最初的口号是坚持和整合开源技术来让编排容器作为微服务架构的一部分，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。 目前行业可能更多处在容器 Docker+Kubernetes, 利用 IaaS、PaaS 和 SaaS 来快速搭建部署应用 基础架构即服务（Infrastructure as a Service，IaaS）、平台即服务（Platform as a Service，PaaS）以及软件即服务（Software as a Service，SaaS）。 Docker 是一个平台，它主要是提供一些服务，任何一台装有 docker 的机器你都可以建立、发布、运行你的应用程序，使用 docker 很省钱省时。 简单的介绍 Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes 定位在 Paas 层，重点解决了微服务大规模部署时的服务编排问题。 # 其实 Serverless 早已和前端产生了联系，只是我们可能没有感知 CDN: 相信大家都使用过 CDN，我们开发完成之后，直接将静态文件部署到 CDN 上，通过 CDN 进行内容分发、网络加速，在这个过程中，前端不需要关心 CDN 有多少个节点、如何做负载均衡，也不需要知道 CDN 的 QPS 是多少。所以从这个角度来说，CDN 是一种 serverless 的实现。 再比如对象存储，和 CDN 一样，我们只需要将文件上传到对象存储，就可以直接使用了，不需要关心它如何存取文件、如何进行权限控制，所以对象存储对前端来说是 Serverless。 甚至一些第三方的 API 服务，也是 Serverless，因为我们使用的时候，不需要去关心服务器。 当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合 简单来讲，FaaS（Function as a Service） 就是一些运行函数的平台，比如阿里云的函数计算、AWS 的 Lambda 等。 BaaS（Backend as a Service）则是一些后端云服务，比如云数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。 Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。 # Serverless 的主要特点 事件驱动 ---- 函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。 无状态 ---- 因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 Redis 等。 Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value [数据库]，并提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从 2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。 无运维 ---- 使用 serverless 我们不需要关心服务器，也不需要关心运维，这也是 serverles 思想的核心； 低成本 ---- 使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源过度 # 常见服务商提供的解决方案 1、上图是当前主要的一些 Serverless 服务，以及对应的服务解决方案。 2、从下往上，分别是基础设施、开发工具和应用场景。 亚马逊 - 微软 - 谷歌 3、基础设施主要是一些云计算厂商提供，包括云计算平台和各种 BaaS 服务，以及运行函数的 FaaS 平台。 前端主要是 Serverless 的使用者，所以对前端来说，最重要的开发工具这一层，我们需要依赖开发工具进行 Serverless 开发、调试和部署。 4、框架（Framework） 如今还没有一个统一的 Serverless 标准，不同云计算平台提供的 Serverless 服务很可能是不一样的，这就导致我们的代码，无法平滑迁移。Serverless 框架一个主要功能是简化 Serverless 开发、部署流程，另一主要功能则是屏蔽不同 Serverless 服务中的差异，让我们的函数能够在不改动或者只改动很小一部分的情况下，在其他 Serverless 服务中也能运行。常见的 Serverless 框架有 Serverless Framework、ZEIT Now、Apex 等。不过这些基本都是国外公司做的，国内还没有这样的平台。 5、Web IDE 和 Serverless 紧密相关的 Web IDE 主要也是各个云计算平台的 Web IDE。利用 Web IDE，我们可以很方便地在云端开发、调试函数，并且可以直接部署到对应的 FaaS 平台。这样的好处是避免了在本地安装各种开发工具、配置各种环境。常见的 Web IDE 有 AWS 的 Cloud9、阿里云的函数计算 Web IDE、腾讯云的 Cloud Studio。 6、当然，目前最主要的开发方式还是在本地进行开发。所以在本地开发 Serverless 的命令行工具也必不可少。 命令行工具主要有两类，一类是云计算平台提供的，如 AWS 的 aws、 Azure 的 az、阿里云的 fun；还有一类是 Serverless 框架提供的，如 serverless、now。 大部分工具如 serverless、fun 等，都是用 Node.js 语言来实现的。 7、应用场景 在开发工具上面一层，则是 Serverless 的一些垂直应用场景。除了使用传统的服务端开发，目前使用 Serverless 技术的还有小程序开发，未来可能还会涉及到物联网领域（IoT）。 # 未来前端 在传统开发流程中，我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题 基于 Serverless，后端变得非常简单，以往的后端应用被拆分为一个个函数，只需要写完函数并部署到 Serverless 服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。 当然，前端基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发。 # 使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。","link":"/blog/2020/04/01/serverless/"},{"title":"vuepress","text":"# 首页 以此站为例，介绍使用 vuepress 搭建博客过程 # 全局安装 123npm install -g vuepress# oryarn global add vuepress # 博客目录 新建 docs 文件夹，docs 文件夹中新建.vuepress 文件夹和 README.md 文件 当前目录生成 package.json 文件 1234567# 1mkdir docscd docsmkdir .vuepressecho &quot;# hello vuepress&quot; &gt; README.md# 2npm init -y # 当前目录文件结构 123456vuepress-demo├── package.json└── docs ├── .vuepress │ └── config.js # 配置 ├── README.md # 首页文件 # 修改 package.json 文件 添加执行脚本 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;vuepress dev docs&quot;, &quot;build&quot;: &quot;vuepress build docs&quot;} # 开发环境运行 1npm run dev # 访问本地端口页面为/docs/README.md文件内的内容 # configjs 配置 12345678910module.exports = { title: '博客', description: '嘎嘣跳的博客', nav: [ { text: '关于', link: 'https://laine001.github.io' } ], sidebar: [ '/' ]} 重启项目，可以看到 title 和 desc。头部右侧多了一个关于选项 # 打包 1npm run build # 跟目录会生成.vuepress文件夹","link":"/blog/2019/10/23/vuepress/"},{"title":"vuex的使用","text":"使用场景 多个视图依赖于同一状态 来自不同视图的行为需要变更这个同一状态 核心概念 12345state // 记录状态即多个组件依赖的变量getter // 相当于单个组件中使用的computed属性，获取state时使用mutation // 更改state中的状态action // 提交mutation操作、异步操作module // 分模块使用store 使用步骤 1234567891011121314151617181920212223242526272829// 登录后存取用户信息及组件中取用或改变state信息// 定义state中的属性const Store = new Vuex.Store({ state: { username: '' }, // 可用可不用 getters: { username(state) { return state.username } }, // 提交改变的为一属性 mutations: { setUsername(state, value) { state.username = value } }, actions: { // setUsernameAsync(state, value) { // state.commit('setUsername', value) // } // 触发mutations中的方法，可做异步操作 setUsernameAsync({ commit }, value) { commit('setUsername', `${value}001`) } }}) 123456789101112131415// 视图中提交改变和取用// 登录后设置username的值this.$store.dispatch('setUsername', 'laine') // 直接提交mutations中的方法改变或this.$store.commit('setUsernameAsync', 'laine') // 通过commit方法触发actions中的方法// 其他组件中取用state中的值this.username = this.$store.state.username或impot { mapGetters } from 'vuex'computed: { ...mapGetters(['username'])} vuex 存储状态不是持久的即刷新页面会清除所有状态 解决方法： 每次提交改变或设置改变时 利用本地存储保存 store 中写入插件 vuex-persist 1npm install vuex-persist -S 1234567import VuexPersistence from 'vuex-persist'const vuexLocal = new VuexPersistence({ storage: window.localStorage})// 和state、getters等同级plugins: [vuexLocal.plugin]","link":"/blog/2019/08/26/vuex/"},{"title":"Vue中使用mock","text":"配置 mock 之前需配置好 axios 1npm install mock 基础使用（单独页面中使用） 1&lt;button @click=&quot;getData&quot;&gt; 生成数据 &lt;/button&gt; 12345678910111213141516171819import Mock from 'mockjs' // node方式引入 (CommonJS)export default { name: 'HelloWorld', data() { return { mockData: [] // 生成数据 } }, methods: { getRandom () { this.mockData = Mock.mock({ //生成数据规则 'list|1-10': [{ 'id|+1': 1 }] }) document.body.innerHTML += '&lt;pre&gt;' + JSON.stringify(this.mockData, null, 4) + '&lt;/pre&gt;' // 展示到页面中 } } 全局配置 配置好的 requestjs 文件中 12345678910111213141516171819202122232425262728293031323334353637import axios from 'axios'// axios.defaults.headers.post['Content-Type'] = 'application/x-www-urlencoded'const http = axios.create()http.defaults.timeout = 3000http.interceptors.request.use(config =&gt; { // 请求拦截器配置 // 可不配置 // do sth return config}, error =&gt; { console.log(error) return Promise.reject(error)})http.interceptors.response.use(response =&gt; { // 响应拦截器配置 // 可不配置 // do something return response}, error =&gt; { console.log(error) return Promise.reject(error)})export function fetch(url, params) { // 封装axios的post请求 return new Promise((resolve, reject) =&gt; { // promise 用法,自行查阅 axios.post(url, params).then(response =&gt; { resolve(response.data) // promise相关 }).catch(error =&gt; { reject(error) // promise相关 }) })}export default { // 暴露htto_mock方法，即后面页面中用到的方法 http_mock(url, params) { return fetch(url, params) }} 然后配置 mockjs 1234567891011121314151617181920import Mock from 'mockjs'const Random = Mock.Randomvar listData = function() { let _data = [] for (let i = 0; i &lt; 20; i++) { let newList = { // 详细 规则 参照mockjs官网 title: Random.csentence(5, 30), // Random.csentence( min, max ) imgSrc: Random.dataImage('200x160', '这是图片中的文本'), // Random.dataImage( size, text ) 生成图片（base64位数据格式） author_name: Random.cname(), // Random.cname() 随机生成中文名 date: Random.date() + ' ' + Random.time() // Random.date()指示生成的日期字符串的格式,默认为yyyy-MM-dd；Random.time() 返回一个随机的时间字符串 } _data.push(newList) } return {_data: _data}}// url为要拦截的请求地址 请求方式 请求数据（规则） （此处api会被mockjs拦截）Mock.mock('http://route.showapi.com/60-27', 'post', listData) mainjs 中引入即可 1import request from '@/http/request' 最后就是页面中使用了 1234567891011// import request from '@/http/request' // 页面中引入配置好的api请求created () { this.getData()},method: { getData() { // 假装要使用http_mock发送请求（#手动滑稽#）（mock自动拦截请求并生成数据） request.http_mock('http://route.showapi.com/60-27','api_id=63114&amp;api_sign=3847b0').then(response =&gt; { console.log(response._data) } } } 完事其他页面中引入下就能使用了，后台接口对接好之后，mockjs 直接取消使用就 ok 了","link":"/blog/2019/02/02/vue%E4%B8%AD%E4%BD%BF%E7%94%A8mock/"},{"title":"vue中使用ts入门","text":"# 为什么使用 typescript 支持所有原生 javscript 的语法 类型检查。使 js 具有强类型语言的特性 vscode 支持友好 微软开源，各大框架源码等皆开始使用 ts 开发 # vue 中使用 typescript vue create ts-demo 时选择 Typescript、class-style 的语法 下载 vue-class-component、vue-property-decorator 插件 # ts 基础使用 官方快速上手教程","link":"/blog/2020/06/16/vue%E4%B8%AD%E4%BD%BF%E7%94%A8ts%E5%85%A5%E9%97%A8/"},{"title":"解决vue项目打包vendorjs文件过大","text":"项目上线后，浏览器第一次加载会特别特别慢，network 中看到 vendorjs 文件 1.9M，不慢才怪。 echarts 按需引入后，也有 1.1M 左右，由于对 vuecli (2.x) 理解不深，自己扒了大量的文档，又测试了很多次，才测试成功，暂时简单记录下。 12//可以查看项目文件大小分析npm run build --report app.js 存放页面中的 js 操作，使用路由的按需加载，可把 app.js 分隔成多个小的 js 文件 此时分隔好的 js 文件要看各页面中的业务代码量，其中我这里单独的一个图表页还是很大， 800k 左右，又是 echarts 的锅。暂时放这。 vendorjs 中是项目中所有引用的依赖包，即使用的 vue、eleui、axios 等等插件框架什么的都在这里边，怪不得大。 参考文档，找到以下解决方法： cdn 引入插件 打包时使用 Gzip # cdn 引入 index.html 文件中引入 link/script 引入 (cdn 或 ukg 链接) build/webpack.base.conf.js 中添加 external 配置，webpack 打包时会跳过配置中的插件 去除 import…from… 和 use 什么的，不去除照样会打包，其他照常然后就 OK 了，我看到的文档大都是这样的，不是很清晰哈，那看代码 index.html (tips: 先后顺序、引入的地方) 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;title&gt;myapp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- cdn引入 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack 配置123456789101112131415module.exports = {context: path.resolve(__dirname, '../'),entry: { ...},externals: { // 要引入的资源的名字：该模块提供给外部引用的名字(由对应的库自定) 'vue': 'Vue', 'vue-router': 'VueRouter', 'element-ui': 'ELEMENTUI', 'echarts': 'echarts'},output: { ....19} main.js 中 (tips: 文件中 import router from ‘./router’ 并不是引入的 vueRouter 看路径) 123456789101112131415161718192021// import Vue from 'vue'import App from './App'// 这里不是引入的vueRouterimport router from './router'// import ElementUI from 'element-ui'// import 'element-ui/lib/theme-chalk/index.css'// import echarts from 'echarts'Vue.config.productionTip = false// Vue.use(ElementUI)// Vue.prototype.$echarts = echarts/* eslint-disable no-new */new Vue({ el: '#app', router, components: { App }, template: '&lt;App/&gt;'}) router/index.js 文件下 （tips: 脚手架中初始使用的为 router 这里要改为 VueRouter 原因看 external 那一步） 123456789101112131415// import Vue from 'vue'// import router from 'vue-router' // 这里才是引入的路由import HelloWorld from '@/components/HelloWorld'// Vue.use(VueRouter)export default new VueRouter({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld } ]}) 这样配置好之后，开发环境下，项目照常是可以运行的，打包后查看文件大小分布，嗯～真香。","link":"/blog/2018/02/03/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8Evendorjs%E4%B8%BB%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7/"},{"title":"webpack工程化","text":"# webpack 是什么 webpack 是一个现代 JavaScript 应用程序的静态模块打包器 (module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图 (dependency graph)， 其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle # 几个基本概念 entry 入口文件 output 输出 loader plugins # entry 入口文件，类似于其他语言的起始文件 指示 webpack 使用某个文件作为构建内部依赖图的开始，可以为多个 以 entry 属性配置 # output 告诉 webpack 构建好后 在哪里输出所创建的 bundle 及如何命名等 output: # loader 让 webpack 处理非 javascript 文件 (webpack 自身只理解 js) loader 可以将各个类型的文件转换为 webpack 可以处理的模块 如 css less vue jsx’ # plugins 打包优化和压缩，重新定义环境中的变量等更广的任务 # 基础 demo 理解打包模式 # 建立工程目录 123456789101112131415mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install webpack webpack-cli --save-dev# 目录结构# webpack-demo/src - index.js/dist - index.htmlpackage.jsonwebpack.config.js # 编写 /src/index.js 1234var dom = document.createElement('div)dom.innerHTML = 'hello webpack'document.body.appendChild(dom) # 编写 /dist/index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;xxx&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; # 编写 webpack.config.js 12345678module.exports = { mode: 'development', entry: './src/index.js', output: { path: __dirname + '/dist', filename: 'bundle.js' }} # 构建 12npx webpack# 查看dist下的index.html是否生效 # 配置 loader 加载 css # loader 原理 很多 loader 的职责都是单一的，只需要完成一种转换。 若一个源文件需要多步转换才能使用，就需要多个 loader 去转换，loader 会顺序执行 # 一个最简单的 loader 源码 12345678910111213141516171819202122232425262728293031323334353637383940// 运行在nodejs中const sass = require('node-sass')module.exports = function(source) { // source 为 compiler 传递给 Loader 的一个文件的原内容 // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换 // return source // or return sass(source)}// 使用// nodemodule中// module.exports = {// module: {// rules: [// {// test: /\\.sass$/',// use: ['sass-loader', 'node-sass'],// // include// }// ]// }// }// 自定义文件（vuecli中）// vue.config.jsmodule.exports = { configureWebpack: config =&gt; { config.module.rules.push({ test: /\\.txt$/, use: [ { // 文件在本地的地址 loader: path.resolve('./test-loader'), // options: {} } ] }) }} # bable-loader 转换 es6 12345678910111213141516171819module.exports = function(source) { // 通过 this.callback 告诉 Webpack 返回的结果 this.callback(null, source, sourceMaps); // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 return // 其中的 this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信 // this.callback( // // 当无法转换原内容时，给 Webpack 返回一个 Error // err: Error | null, // // 原内容转换后的内容 // content: string | Buffer, // // 用于把转换后的内容得出原内容的 Source Map，方便调试 // sourceMap?: SourceMap, // // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 // abstractSyntaxTree?: AST // )} # plugins 原理 # 编写 plugin 1234567891011121314151617181920class DemoPlugin { // 在构造函数中获取用户给该插件传入的配置 constructor(option) { } // Webpack 会调用 DemoPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply(compiler) { compiler.plugin('compilation', function(compilation) { }) }}modue.exports = DemoPlugin// 使用const DemoPlugin = require('./DemoPlugin.js')module.export = { plugins: [ new DemoPlugin(options) ]}","link":"/blog/2020/06/12/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"title":"→_→","text":"谁这样写的 过来挨锤 →_→ 1234567891011121314151617181920212223242526272829// baddata() { return { // 禁止编辑 ban: true // isDisabled: true }}// badif (item.leafNum === 0) { item.leaf = true} else { item.leaf = false}// item.leaf === item.leafNum === 0// so badif(this.$route.query.type == 'add'){ this.baseForm.deptName = this.$store.getters.deptName this.baseForm.modelLevel = this.$store.getters.areaLevel}else{this.baseForm.deptName = res.deptNamethis.baseForm.modelLevel = res.modelLevel}// if () {// ...// } else {// ...// }","link":"/blog/2020/06/02/%E4%BB%A3%E7%A0%81/"},{"title":"公司内部分享md","text":"# koa 基础初步使用 Koa 由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 没有捆绑任何中间件， 而是提供了一套优雅的方法去编写服务端应用程序 # 安装、启动服务 12npm initnpm install koa 123456const koa = require('koa')const app = new koa()// 启动服务 端口为3000app.listen(3000)// 使用node app命令启动服务 这样每次修改文件都需要重新启动服务，可以使用 nodemon 监听文件变化自动重启 npm install nodemon -g 然后启动服务时，使用 nodemon app.js # 响应返回 1234567891011const koa = require('koa')const app = new koa()app.use(async ctx =&gt; { ctx.body = 'Hello World';})// 启动服务 端口为3000// 浏览器访问locahost:3000 返回hello worldapp.listen(3000) # 使用 koa-router 插件管理路由 为 koa 设计的路由中间件，路由由 url 生成 12345678910111213141516const koa = require('koa')const app = new koa()// 引入路由、实例化const router = require('koa-router')()router.get('/api/testapi', async ctx =&gt; { // const data = await fetchData() const data = '这是从testapi返回出去的数据' ctx.body = data})app.use(router.routes())app.use(router.allowedMethods())// 浏览器访问locahost:3000/api/testapiapp.listen(3000) # 爬取数据 # 安装插件、首次完整抓取 12# 安装所需插件npm install superagent cheerio superagent-charset 1234567891011121314151617181920212223242526const koa = require('koa')const app = new koa()const router = require('koa-router')()// 引入插件const charset = require('superagent-charset')const superagent = require('superagent')charset(superagent)const cheerio = require('cheerio')superagent.get('https://s.weibo.com/top/summary?cate=realtimehot') .charset() .end((err, sres) =&gt; { const html = sres.text console.log(html) })router.get('/api/testapi', async ctx =&gt; { const data = '这是从testapi返回出去的数据' ctx.body = data})app.use(router.routes())app.use(router.allowedMethods())app.listen(3000) 此时启动服务，就会去访问微博热搜页面，命令行中打印页面源码说明爬取成功 # 分析节点源码，处理数据 1234567891011121314151617181920const $ = cheerio.load(html)let hotList = []$(&quot;#pl_top_realtimehot table tbody tr&quot;).each(function(index) { if (index !== 0) { const $td = $(this).children().eq(1); const link = 'https://s.weibo.com' + decodeURI($td.find(&quot;a&quot;).attr(&quot;href&quot;)); const text = $td.find(&quot;a&quot;).text(); const hotValue = $td.find(&quot;span&quot;).text(); const icon = $td.find(&quot;img&quot;).attr(&quot;src&quot;) ? &quot;https:&quot; + $td.find(&quot;img&quot;).attr(&quot;src&quot;) : &quot;&quot;; hotList.push({ sort: index, link, text, hotValue, icon, }) }}) # 前端请求数据、查看接口返回 本地环境中，koa 服务需要设置 cors 以允许跨域访问 使用 koa-router 管理请求 1npm install koa2-cors koa-router --save 12345678910111213141516171819202122const Koa = require('koa')const app = new Koa()const router = require('koa-router')();// 设置允许跨域访问服务const cors = require('koa2-cors')app.use(cors())- app.use(async ctx =&gt; {- const data = await getSinaData()- ctx.body = data- })+ router.get('/api/getSinaHotSearchList', async ctx =&gt; {+ const data = await getSinaData()+ ctx.body = data+ })app.listen(3000, () =&gt; { console.log(`success and it is listening at port 3000`)}) 页面接口请求、查看返回数据 12345fetch.get('http://localhost:3000/api/getSinaHotSearchList') .then(response =&gt; response.json()) .then(res =&gt; { console.log(res) })","link":"/blog/2020/09/08/%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E5%88%86%E4%BA%ABmd/"},{"title":"前端面试题","text":"# 原生 js # 描述 js 的事件循环机制 进程和线程 浏览器是多进程的，因为系统给它的进程分配了资源（cpu、内存）（打开 Chrome 会有一个主进程，每打开一个 Tab 页就有一个独立的进程）。一个进程里可以有单个或多个线程 JavaScript 有一个 main thread 主线程和 call-stack 调用栈（执行栈），所有的任务都会放到调用栈中等待主线程执行。 宏任务 (macro-task)、微任务 (micro-task) 除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。 macro-task 包括：script (整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task 包括：process.nextTick, Promises, Object.observe, MutationObserver。 # 手动实现浅拷贝、深拷贝 1234567891011121314151617181920// 基础版function clone(target) { let cloneTarget = {} for (const key in target) { cloneTarget[key] = target[key] } return cloneTarget}// 只考虑{}function deepClone(target) { if (typeof target === 'object') { let cloneTarget = {} for (const key in target) { cloneTarget[key] = deepClone(target[key]) } return cloneTarget } else { return target }} # 手动实现防抖节流函数 123456789101112131415161718192021222324252627282930313233343536373839404142// 防抖// keyup事件、resize scrollfunction debounce(fn, delay, scope) { let timer = null; // 返回函数对debounce作用域形成闭包 return function () { // setTimeout()中用到函数环境总是window,故需要当前环境的副本； let context = scope || this, args = arguments; // 如果事件被触发，清除timer并重新开始计时 clearTimeout(timer); timer = setTimeout(function () { fn.apply(context, args); }, delay); }}// 节流function throttle(fn, threshold, scope) { let timer; let prev = Date.now(); return function () { let context = scope || this, args = arguments; let now = Date.now(); if (now - prev &gt; threshold) { prev = now; fn.apply(context, args); } }}function throttle2(fn, threshold, scope) { let timer; return function () { let context = scope || this, args = arguments; if (!timer) { timer = setTimeout(function () { fn.apply(context, args); timer = null; }, threshold) } }} # new 操作符过程发生了什么 # 实现冒泡排序、快速排序 # 为什么会有跨域、怎么解决 # 继承（手写 class 继承） 123456789101112131415161718class Person { constructor(name, age) { this.name = name this.age = age } sayHello(name) { console.log(`hello ${name}`) }}class men extends Person { constuctor(name, age) { super(name, age) }}const xiaohong = new Person('小红', 18)xiaohong.sayHello() // hello 小红const xiaogang = new men('小刚', 20)xiaogang.sayHello() # Promise 简述 # vue # Vue 双向绑定、router 原理 # nextTick 原理 # react # react 的 setState 是同步异步？为什么 # react 生命周期，各生命周期作用 1234567componentWillMount() – 在渲染之前执行，在客户端和服务器端都会执行。componentDidMount() – 仅在第一次渲染后在客户端执行。componentWillReceiveProps() – 当从父类接收到 props 并且在调用另一个渲染器之前调用。shouldComponentUpdate() – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。componentWillUpdate() – 在 DOM 中进行渲染之前调用。componentDidUpdate() – 在渲染发生后立即调用。componentWillUnmount() – 从 DOM 卸载组件后调用。用于清理内存空间。 # 简述 redux 123456789101112131415161718192021222324// 三个原则// 单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。// 状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。// 使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。// redux的组件// Action – 这是一个用来描述发生了什么事情的对象。// Reducer – 这是一个确定状态将如何变化的地方。// Store – 整个程序的状态/对象树保存在Store中。// View – 只显示 Store 提供的数据。// 定义action// React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：function addTodo(text) { return { type: ADD_TODO, text }}// 简述// redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，// 工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，// flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰// 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们 # react 类组件和函数组件区别与使用场景 # webpack # webpack 的几大概念？都是做什么的 entry output loader plugin # loader 和 plugins 的区别和基本原理","link":"/blog/2020/06/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"队列数据结构","text":"栈数据结构是遵循先进先出原则的一组有序的项。最新添加的元素必须排在队列的末尾，例：排队 12345678910111213141516171819202122232425/* * enqueue: 向队列尾部添加一个或多个item --- push * dequeue: 移出队列的第一(队列最前面的)item，并返回被移除的元素 * front: 返回队列中的第一个元素(会最先被添加，也会最先被移除),队列不变动 * [不移除元素,只返回元素信息] */// 创建一个队列function Queue() { let items = [] // 属性和方法 console.log('同步执行') enqueue: function(ele) { items.push(ele) } dequeue: function() { return items.shift() } front: function() { return items[0] } print: function() { console.log(items.toString()) }}","link":"/blog/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%85%A1/"},{"title":"算法笔记-排序","text":"排序 123456789101112131415161718192021221. sort 方法let arr = [3, 5, 21, 15，39]arr.sort((a, b) =&gt; a - b)console.log(arr) // [ 3, 5, 15, 21 ]2. 快速排序function quickSort(arr) { const len = arr.length if (len &lt; 1) return arr let leftArr = [], rightArr = [] const midIndex = Math.floor(len / 2) const midNum = arr.splice(midIndex, 1)[0] for (let i = 0; i &lt; len - 1; i++) { if (arr[i] &lt; midNum) { leftArr.push(arr[i]) } else { rightArr.push(arr[i]) } } return quickSort(leftArr).concat([midNum], quickSort(rightArr))} 12345678910111213141516171819202122232425262728293031323334353637383940处理方法splice、sort、concant、push、unshift、 pop、shift// splice(1,3) // 删除索引1后面的三个// splice(1,0,4) // 删除索引1后面的0个，再在后面添加一个4// sort() // 数字中两位的数字只按照第一个排序// sort((a, b) =&gt; return a - b) //1- 冒泡排序算法/* * 排序思想： * 让数组中的当前项和后一项进行比较，如果当前项比后一项大，则两项 * 交换位置（让大的靠后）即可 * 两两比较 * * 每次循环会把最大的放到最后面 * 最多比较length-1次 不用和自己比较 * 即：第二次循环里由于最后一个已经是最大的，所以没有必要再去比较，第二个循环里的循环长度就是length-1，为0时即比较完毕 * * * 空间复杂度O(1) * 平均时间复杂度O(n*n) */let ary = [12, 8, 24, 16, 1]function bubbleSort(ary) { // i控制比较的轮数 for (let i = 0; i &lt; ary.length - 1; i++) { // j控制每一轮比较的次数 for (let j = 0; j &lt; ary.length - i - 1; j++) { // 当前项大于后一项，放后面 if (ary[j] &gt; ary[j + 1]) { let temp = ary[j] ary[j] = ary[j + 1] ary[j + 1] = temp } } } return ary}bubbleSort(ary) // [ 1, 8, 12, 16, 24 ] 1234567891011121314151617181920212223242526272829302- 插入排序算法/* * 思想：找第一个a为基准循环跟其他数值比较，比a大的放后面 * */let arr = [12, 8, 24, 16, 1]function insertSort(arr) { result.push(arr[0]) for (let i = 0; i &lt; arr.length; i++) { let a = arr[i] for(let j = result.length - 1; j &gt;= 0; j-- ) { let b = result[j] if (a &gt; b) { result.splice(j + 1, 0, a) break } if (j === 0) { result.unshift(a) } } } return result}insertSort(arr) 出现次数最多 12输入: [1, 13, 43, 42, 13, 1, 3, 4, 4, 23, 13]输出: [1, 13, 43, 42, 3, 4, 23] 1234567891011function unique(arr) { let hashTable = {} let data = [] for (let i = 0; len = arr.length; i &lt; len; i++) { if (!hashTable[arr[i]]) { hashTable[arr[i]] = true data.push(arr[i]) } } return data}","link":"/blog/2020/03/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vue","slug":"vue","link":"/blog/tags/vue/"},{"name":"数据结构","slug":"数据结构","link":"/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"nodejs","slug":"nodejs","link":"/blog/tags/nodejs/"},{"name":"server","slug":"server","link":"/blog/tags/server/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"}],"pages":[{"title":"","text":"","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"link","text":"","link":"/blog/link/index.html"},{"title":"vuepress","text":"# 首页 此站为例，介绍使用 vuepress 搭建博客过程 # 全局安装 123npm install -g vuepress# oryarn global add vuepress # 博客目录 新建 docs 文件夹，docs 文件夹中新建.vuepress 文件夹和 README.md 文件 当前目录生成 package.json 文件 1234567# 1mkdir docscd docsmkdir .vuepressecho &quot;# hello vuepress&quot; &gt; README.md# 2npm init -y # 当前目录文件结构 123456vuepress-demo├── package.json└── docs ├── .vuepress │ └── config.js # 配置 ├── README.md # 首页文件 # 修改 package.json 文件 添加执行脚本 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;vuepress dev docs&quot;, &quot;build&quot;: &quot;vuepress build docs&quot;} # 开发环境运行 1npm run dev # 访问本地端口页面为/docs/README.md文件内的内容 # configjs 配置 12345678910module.exports = { title: '博客', description: '嘎嘣跳的博客', nav: [ { text: '关于', link: 'https://laine001.github.io' } ], sidebar: [ '/' ]} 重启项目，可以看到 title 和 desc。头部右侧多了一个关于选项 # 打包 1npm run build # 跟目录会生成.vuepress文件夹","link":"/blog/music/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}]}